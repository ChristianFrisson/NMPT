# CMake integration by Christian Frisson (UMONS)

# Project settings
PROJECT(NMPT)
SET(NMPT_VERSION 0.7)
SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -DNMPT_VERSION=${NMPT_VERSION}")
SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -DNMPT_VERSION=${NMPT_VERSION}")

cmake_minimum_required(VERSION 2.6.2)

list(APPEND CMAKE_MODULE_PATHS "${CMAKE_SOURCE_DIR}/cmake")
INCLUDE(${CMAKE_SOURCE_DIR}/cmake/FindLinkedDirectories.cmake)
SET(CMAKE_MODULE_PATH "${CMAKE_MODULE_PATHS}")

# Ubuntu detection
IF(UNIX)
	# Try to find architecture
	execute_process(COMMAND uname -m OUTPUT_VARIABLE CPACK_PACKAGE_ARCHITECTURE)
	string(STRIP "${CPACK_PACKAGE_ARCHITECTURE}" CPACK_PACKAGE_ARCHITECTURE)
	# Try to find distro name and distro-specific arch
	execute_process(COMMAND lsb_release -is OUTPUT_VARIABLE LSB_ID)
	execute_process(COMMAND lsb_release -rs OUTPUT_VARIABLE LSB_RELEASE)
	string(STRIP "${LSB_ID}" LSB_ID)
	string(STRIP "${LSB_RELEASE}" LSB_RELEASE)
	set(LSB_DISTRIB "${LSB_ID}${LSB_RELEASE}")
	IF(NOT LSB_DISTRIB)
		set(LSB_DISTRIB "unix")
	ENDIF(NOT LSB_DISTRIB)
ENDIF()

OPTION(USE_DEBUG "Use Debug" ON)
OPTION(BUILD_SHARED_LIBS "Build libraries as shared" ON)

IF ( USE_DEBUG )
	MESSAGE( "\nConfigured for Debug Build")
	SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -DUSE_DEBUG -DTI_DEBUG=1 -g")
	SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -DUSE_DEBUG -DTI_DEBUG=1 -g")
	SET(CMAKE_BUILD_TYPE "Debug")
	SET(CMAKE_VERBOSE_MAKEFILE ON)
ELSE ( USE_DEBUG )
	MESSAGE( "\nConfigured for Release Build")
	SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -DTI_DEBUG=0 -O3")
	SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -DTI_DEBUG=0 -O3")
	SET(CMAKE_BUILD_TYPE "Release")
	SET(CMAKE_VERBOSE_MAKEFILE OFF)
	IF(APPLE)
		SET(CMAKE_INSTALL_PREFIX "${CMAKE_BINARY_DIR}/release")
	ENDIF()
ENDIF ( USE_DEBUG )

# Apple
IF(APPLE)
	FIND_PACKAGE(CoreFoundation)
	IF(COREFOUNDATION_FOUND)
		MESSAGE("CoreFoundation found: ${COREFOUNDATION_LIBRARY}")
	ELSE()
		MESSAGE("CoreFoundation not found")
	ENDIF()
ENDIF()

# OpenGL
FIND_PACKAGE( OpenGL REQUIRED )
IF ( OPENGL_FOUND )
	MESSAGE ( "Found OpenGL: ${OPENGL_LIBRARIES}" )
	INCLUDE_DIRECTORIES( ${OPENGL_INCLUDE_DIR} )
ELSE ( OPENGL_FOUND )
	MESSAGE(FATAL_ERROR "OpenGL not found.")
ENDIF ( OPENGL_FOUND )

# GLUT
FIND_PACKAGE( GLUT )
IF ( GLUT_FOUND )
	MESSAGE ( "Found GLUT: ${GLUT_LIBRARIES}" )
	INCLUDE_DIRECTORIES( ${GLUT_INCLUDE_DIR} )
ELSE ( GLUT_FOUND )
	MESSAGE(FATAL_ERROR "GLUT not found.")
ENDIF ( GLUT_FOUND )


# OpenCV
SET(OpenCV_MIN_VERSION "2.3.1")
#SET(OpenCV_CONFIG_PATH "${OpenCV_DIR}")
find_path(OpenCV_DIR NAMES opencv-config.cmake OpenCVConfig.cmake PATH_SUFFIXES lib/cmake lib)
FIND_PACKAGE ( OpenCV REQUIRED COMPONENTS core contrib features2d imgproc legacy objdetect video highgui)
IF(OpenCV_FOUND)
	IF(${OpenCV_VERSION} VERSION_LESS ${OpenCV_MIN_VERSION} AND (SUPPORT_VIDEO OR SUPPORT_IMAGE) )
		MESSAGE(FATAL_ERROR "OpenCV version (${OpenCV_VERSION} is present, while ${OpenCV_MIN_VERSION}+ is required")
	ENDIF()
	INCLUDE_DIRECTORIES(${OpenCV_INCLUDE_DIRS})
	IF(MINGW OR WIN32)
		SET(OpenCV_LIBRARIES ${OpenCV_LIBS_OPT} ${OpenCV_EXTRA_LIBS_OPT})
	ELSE()
		SET(OpenCV_LIBRARIES ${OpenCV_LIBS})
	ENDIF()
	MESSAGE("Found OpenCV ${OpenCV_VERSION} libraries ${OpenCV_LIBRARIES} and headers ${OpenCV_INCLUDE_DIRS}")
	IF(${OpenCV_VERSION_MAJOR} MATCHES 2 AND ${OpenCV_VERSION_MINOR} MATCHES 2)
		ADD_DEFINITIONS(-DUSE_OPENCV22)
	ELSE()
		ADD_DEFINITIONS(-DUSE_OPENCV)
	ENDIF()
ELSE()
	MESSAGE(FATAL_ERROR "OpenCV not found.")
ENDIF()

# Project library and executables
MESSAGE("\nTargets:")
SET(LIBRARY_NAME "NMPT")
#SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}-std=c++0x")
#SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -std=c++0x")

INCLUDE_DIRECTORIES(include)

FILE(GLOB ${LIBRARY_NAME}_SRCS lib/*.cpp)
FILE(GLOB ${LIBRARY_NAME}_HDRS include/*.h)

ADD_LIBRARY(${LIBRARY_NAME} ${${LIBRARY_NAME}_SRCS} ${${LIBRARY_NAME}_HDRS})
TARGET_LINK_LIBRARIES(${LIBRARY_NAME} )

TARGET_LINK_LIBRARIES(${LIBRARY_NAME} ${OpenCV_LIBRARIES})

MESSAGE("[X] ${LIBRARY_NAME}")

FILE(GLOB ${LIBRARY_NAME}_TESTS_SRCS src/*.cpp)

FOREACH(TEST_CLASS ${${LIBRARY_NAME}_TESTS_SRCS})
	GET_FILENAME_COMPONENT(EXECUTABLE_NAME "${TEST_CLASS}" NAME_WE)
	MESSAGE("[X] ${EXECUTABLE_NAME}")
	ADD_EXECUTABLE(${EXECUTABLE_NAME} ${TEST_CLASS})
	TARGET_LINK_LIBRARIES(${EXECUTABLE_NAME} ${LIBRARY_NAME})
ENDFOREACH()


