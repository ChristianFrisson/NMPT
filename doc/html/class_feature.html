<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Nick&#39;s Machine Perception Toolbox: Feature Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>Feature Class Reference<br/>
<small>
[<a class="el" href="group___aux_group.html">Auxilliary Tools</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Feature" -->
<p><code>Auxilliary Tool:</code> A purely virtual class for providing the skeleton for specific features. This allows different features to be manipulated using a common set of tools.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;Feature.h&gt;</code></p>
<!-- startSectionHeader --><div class="dynheader">
Inheritance diagram for Feature:<!-- endSectionHeader --></div>
<!-- startSectionSummary --><!-- endSectionSummary --><!-- startSectionContent --><div class="dyncontent">
<div class="center"><img src="class_feature__inherit__graph.png" border="0" usemap="#_feature_inherit__map" alt="Inheritance graph"/></div>
<map name="_feature_inherit__map" id="_feature_inherit__map">
<area shape="rect" id="node3" href="class_box_feature.html" title="Auxilliary Tool: A linear feature that uses the &quot;Integral &#160;Image&quot; trick to efficiently eval..." alt="" coords="9,83,103,112"/><area shape="rect" id="node5" href="class_haar_feature.html" title="Auxilliary Tool: A linear feature that uses Haar Wavelets, which are a certain kind of box filter..." alt="" coords="5,160,107,189"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center><!-- endSectionContent --></div>

<p><a href="class_feature-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature.html#a1ce7ec5292ac9b1d46a5b580f8811b8c">evaluateImagePatch</a> (const <a class="el" href="class_image_patch.html">ImagePatch</a> *patch)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn an <a class="el" href="class_image_patch.html" title="Auxilliary Tool: A data structure that represents an image in an efficient memory layout...">ImagePatch</a> into a scalar value. This is the basic job of any feature. Must be overridden in derived classes.  <a href="#a1ce7ec5292ac9b1d46a5b580f8811b8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature.html#a6f34255586af418bffa852fc4896b87e">evaluateImagePatch</a> (const <a class="el" href="class_image_patch.html">ImagePatch</a> &amp;patch)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn an <a class="el" href="class_image_patch.html" title="Auxilliary Tool: A data structure that represents an image in an efficient memory layout...">ImagePatch</a> into a scalar value. This is the basic job of any feature.  <a href="#a6f34255586af418bffa852fc4896b87e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature.html#a2715c655465e0b91e58d989298e06fe5">filterPatchList</a> (<a class="el" href="class_patch_list.html">PatchList</a> *patches)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the feature to a <a class="el" href="class_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">PatchList</a> data structure. Must be overridden in derived classes.  <a href="#a2715c655465e0b91e58d989298e06fe5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature.html#a2e8f002043690e2bd6b8c0b45ba3a70e">setFeatureParameters</a> (const cv::Mat &amp;paramVec)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic feature initialization. Must be overridden in derived classes.  <a href="#a2e8f002043690e2bd6b8c0b45ba3a70e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="class_feature.html">Feature</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature.html#a7f0f2f2605e7cf9a227b8ac3547ad97b">getSimilarFeatures</a> (int numFeatures=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get features similar to the current feature. This is useful for searching through feature space for local optima.  <a href="#a7f0f2f2605e7cf9a227b8ac3547ad97b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature.html#a2963467d6f8506d86ea26b753df50da4">getFeatureVisualization</a> (cv::Mat &amp;dest)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a nice visual representation of the feature.  <a href="#a2963467d6f8506d86ea26b753df50da4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature.html#af57293798eb02dee696ace1f76c56f9c">debugInfo</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints information about this feature for help debugging. By default, this prints the feature type, and its parameters.  <a href="#af57293798eb02dee696ace1f76c56f9c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac74e4360e975b5003f6d9e1bed6cc4be"></a><!-- doxytag: member="Feature::~Feature" ref="ac74e4360e975b5003f6d9e1bed6cc4be" args="()" -->
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature.html#ac74e4360e975b5003f6d9e1bed6cc4be">~Feature</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. By default, this cleans up the parameters, valid parameter ranges, kernel image, and name. Subclasses are responsible for cleaning up extra memory. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_feature.html">Feature</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature.html#acf5a29ea61186c95098796c56ca8fc07">getFeatureOfSameTypeAndSize</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a feature with same type / dimension as this one, but random parameters.  <a href="#acf5a29ea61186c95098796c56ca8fc07"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_feature.html">Feature</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature.html#ab46c084301ef79847d71d58e7ee16269">copy</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a feature with the same type / dimension / parameters as this one.  <a href="#ab46c084301ef79847d71d58e7ee16269"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature.html#ae3b722740c1589c9252907a79512bc8b">evaluateImagePatches</a> (const std::vector&lt; <a class="el" href="class_image_patch.html">ImagePatch</a> * &gt; &amp;imagePatches, std::vector&lt; double &gt; &amp;scalarVals)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply feature to multiple <a class="el" href="class_image_patch.html" title="Auxilliary Tool: A data structure that represents an image in an efficient memory layout...">ImagePatch</a> objects.  <a href="#ae3b722740c1589c9252907a79512bc8b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature.html#a117477622f1bfc69739ef356c4ff1df5">evaluateImagePatches</a> (const std::vector&lt; <a class="el" href="class_image_patch.html">ImagePatch</a> &gt; &amp;imagePatches, std::vector&lt; double &gt; &amp;scalarVals)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply feature to multiple <a class="el" href="class_image_patch.html" title="Auxilliary Tool: A data structure that represents an image in an efficient memory layout...">ImagePatch</a> objects.  <a href="#a117477622f1bfc69739ef356c4ff1df5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature.html#a423036cab50b31a4d62ac90aed2bf61c">evaluateImagePatches</a> (const std::vector&lt; <a class="el" href="class_image_patch.html">ImagePatch</a> * &gt; &amp;imagePatches, cv::Mat &amp;scalarVals)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply feature to multiple <a class="el" href="class_image_patch.html" title="Auxilliary Tool: A data structure that represents an image in an efficient memory layout...">ImagePatch</a> objects.  <a href="#a423036cab50b31a4d62ac90aed2bf61c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature.html#ae8c8a5cb52f54cb64d0b80582ac946fd">evaluateImagePatches</a> (const std::vector&lt; <a class="el" href="class_image_patch.html">ImagePatch</a> &gt; &amp;imagePatches, cv::Mat &amp;scalarVals)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply feature to multiple <a class="el" href="class_image_patch.html" title="Auxilliary Tool: A data structure that represents an image in an efficient memory layout...">ImagePatch</a> objects.  <a href="#ae8c8a5cb52f54cb64d0b80582ac946fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cv::Size&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature.html#a44e27612bc6373341c6967b526f51a20">getPatchSize</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of patch that is "natural" for this feature.  <a href="#a44e27612bc6373341c6967b526f51a20"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_feature.html">Feature</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature.html#ae7671cfca735bc2a6e02930d08375657">getFeatureOfType</a> (std::string featureName, cv::Size patchSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a subclass based on its name. If you subclass <a class="el" href="class_feature.html" title="Auxilliary Tool: A purely virtual class for providing the skeleton for specific features. This allows different features to be manipulated using a common set of tools.">Feature</a>, you are responsible for modifying Feature.cpp to make this function aware of your feature. This function is important for saving the state of features for classifiers.  <a href="#ae7671cfca735bc2a6e02930d08375657"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8e3090a70767894ee004a5e1da154f4"></a><!-- doxytag: member="Feature::operator&lt;&lt;" ref="ae8e3090a70767894ee004a5e1da154f4" args="(std::ostream &amp;ofs, Feature *feat)" -->
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature.html#ae8e3090a70767894ee004a5e1da154f4">operator&lt;&lt;</a> (std::ostream &amp;ofs, <a class="el" href="class_feature.html">Feature</a> *feat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to a file. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5a5da679e2ceb85ff32123164762ebc"></a><!-- doxytag: member="Feature::operator&gt;&gt;" ref="af5a5da679e2ceb85ff32123164762ebc" args="(std::istream &amp;ifs, Feature *&amp;feat)" -->
std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature.html#af5a5da679e2ceb85ff32123164762ebc">operator&gt;&gt;</a> (std::istream &amp;ifs, <a class="el" href="class_feature.html">Feature</a> *&amp;feat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from a file. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><code>Auxilliary Tool:</code> A purely virtual class for providing the skeleton for specific features. This allows different features to be manipulated using a common set of tools. </p>
<p>In general, we conceive of a feature as something that takes an image patch as input, and produces a scalar output. It may be necessary at times for a feature to apply itself efficiently to multiple image patches, using the <a class="el" href="class_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">PatchList</a> data structure. Also, it will be necessary to find features similar to this one, and may be convenient to represent a feature in a compact parameterized form. Thus, a feature should implement the following:</p>
<p>virtual double <a class="el" href="class_feature.html#a1ce7ec5292ac9b1d46a5b580f8811b8c" title="Turn an ImagePatch into a scalar value. This is the basic job of any feature. Must be overridden in d...">evaluateImagePatch(const ImagePatch* patch)</a>; virtual void <a class="el" href="class_feature.html#a2715c655465e0b91e58d989298e06fe5" title="Apply the feature to a PatchList data structure. Must be overridden in derived classes.">filterPatchList( PatchList* patches)</a>; virtual void setFeatureParameters(const CvMat* paramVec);</p>
<p>Additionally, the following utilities are provided but may be overridden:</p>
<p>virtual vector&lt;Feature*&gt; <a class="el" href="class_feature.html#a7f0f2f2605e7cf9a227b8ac3547ad97b" title="Get features similar to the current feature. This is useful for searching through feature space for l...">getSimilarFeatures(int numFeatures)</a>; virtual IplImage* visualizeFeature(); virtual string <a class="el" href="class_feature.html#af57293798eb02dee696ace1f76c56f9c" title="Prints information about this feature for help debugging. By default, this prints the feature type...">debugInfo() const</a>; virtual <a class="el" href="class_feature.html#ac74e4360e975b5003f6d9e1bed6cc4be" title="Destructor. By default, this cleans up the parameters, valid parameter ranges, kernel image...">~Feature()</a>;</p>
<p>NOTE ON SUBCLASSING: In order for everything to work properly, a few rules need to be followed. First, subclasses should be able to completely reinitialize their own member variables from their parameter vector. This allows us to save a parameter vector to disk and then reconstruct the feature later. Second, subclasses should set the protected "featureName" variable, which helps determine which what the actual type of a saved feature is. Third (finally), Feature.cpp's getFeatureOfType method must be modified to be aware of your feature class, by calling the correct constructor (your constructor) when a feature of your type is read from disk.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>Nicholas Butko </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>2010 </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>0.4 </dd></dl>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ab46c084301ef79847d71d58e7ee16269"></a><!-- doxytag: member="Feature::copy" ref="ab46c084301ef79847d71d58e7ee16269" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_feature.html">Feature</a> * Feature::copy </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a feature with the same type / dimension / parameters as this one. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new feature. </dd></dl>

</div>
</div>
<a class="anchor" id="af57293798eb02dee696ace1f76c56f9c"></a><!-- doxytag: member="Feature::debugInfo" ref="af57293798eb02dee696ace1f76c56f9c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string Feature::debugInfo </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints information about this feature for help debugging. By default, this prints the feature type, and its parameters. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Information about this feature useful for debugging. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f34255586af418bffa852fc4896b87e"></a><!-- doxytag: member="Feature::evaluateImagePatch" ref="a6f34255586af418bffa852fc4896b87e" args="(const ImagePatch &amp;patch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Feature::evaluateImagePatch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_image_patch.html">ImagePatch</a> &amp;&#160;</td>
          <td class="paramname"> <em>patch</em>&#160;)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Turn an <a class="el" href="class_image_patch.html" title="Auxilliary Tool: A data structure that represents an image in an efficient memory layout...">ImagePatch</a> into a scalar value. This is the basic job of any feature. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">patch</td><td>The image patch to evaluate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value of the Image Patch according to the feature. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ce7ec5292ac9b1d46a5b580f8811b8c"></a><!-- doxytag: member="Feature::evaluateImagePatch" ref="a1ce7ec5292ac9b1d46a5b580f8811b8c" args="(const ImagePatch *patch)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double Feature::evaluateImagePatch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_image_patch.html">ImagePatch</a> *&#160;</td>
          <td class="paramname"> <em>patch</em>&#160;)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Turn an <a class="el" href="class_image_patch.html" title="Auxilliary Tool: A data structure that represents an image in an efficient memory layout...">ImagePatch</a> into a scalar value. This is the basic job of any feature. Must be overridden in derived classes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">patch</td><td>The image patch to evaluate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value of the Image Patch according to the feature. </dd></dl>

<p>Implemented in <a class="el" href="class_box_feature.html#a92c8f0475fcc513593fe52d68973ee77">BoxFeature</a>.</p>

</div>
</div>
<a class="anchor" id="a423036cab50b31a4d62ac90aed2bf61c"></a><!-- doxytag: member="Feature::evaluateImagePatches" ref="a423036cab50b31a4d62ac90aed2bf61c" args="(const std::vector&lt; ImagePatch * &gt; &amp;imagePatches, cv::Mat &amp;scalarVals)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Feature::evaluateImagePatches </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_image_patch.html">ImagePatch</a> * &gt; &amp;&#160;</td>
          <td class="paramname"> <em>imagePatches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>scalarVals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply feature to multiple <a class="el" href="class_image_patch.html" title="Auxilliary Tool: A data structure that represents an image in an efficient memory layout...">ImagePatch</a> objects. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">imagePatches</td><td>Patches to evaluate. </td></tr>
    <tr><td class="paramname">scalarVals</td><td>Result of evaluation, in a CvMat data structure. If the provided CvMat is NULL or has inappropriate size, it will be freed and recreated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae8c8a5cb52f54cb64d0b80582ac946fd"></a><!-- doxytag: member="Feature::evaluateImagePatches" ref="ae8c8a5cb52f54cb64d0b80582ac946fd" args="(const std::vector&lt; ImagePatch &gt; &amp;imagePatches, cv::Mat &amp;scalarVals)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Feature::evaluateImagePatches </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_image_patch.html">ImagePatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"> <em>imagePatches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>scalarVals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply feature to multiple <a class="el" href="class_image_patch.html" title="Auxilliary Tool: A data structure that represents an image in an efficient memory layout...">ImagePatch</a> objects. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">imagePatches</td><td>Patches to evaluate. </td></tr>
    <tr><td class="paramname">scalarVals</td><td>Result of evaluation, in a CvMat data structure. If the provided CvMat is NULL or has inappropriate size, it will be freed and recreated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae3b722740c1589c9252907a79512bc8b"></a><!-- doxytag: member="Feature::evaluateImagePatches" ref="ae3b722740c1589c9252907a79512bc8b" args="(const std::vector&lt; ImagePatch * &gt; &amp;imagePatches, std::vector&lt; double &gt; &amp;scalarVals)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Feature::evaluateImagePatches </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_image_patch.html">ImagePatch</a> * &gt; &amp;&#160;</td>
          <td class="paramname"> <em>imagePatches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"> <em>scalarVals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply feature to multiple <a class="el" href="class_image_patch.html" title="Auxilliary Tool: A data structure that represents an image in an efficient memory layout...">ImagePatch</a> objects. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">imagePatches</td><td>Patches to evaluate. </td></tr>
    <tr><td class="paramname">scalarVals</td><td>Result of evaluation, in an STL vector data structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a117477622f1bfc69739ef356c4ff1df5"></a><!-- doxytag: member="Feature::evaluateImagePatches" ref="a117477622f1bfc69739ef356c4ff1df5" args="(const std::vector&lt; ImagePatch &gt; &amp;imagePatches, std::vector&lt; double &gt; &amp;scalarVals)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Feature::evaluateImagePatches </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_image_patch.html">ImagePatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"> <em>imagePatches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"> <em>scalarVals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply feature to multiple <a class="el" href="class_image_patch.html" title="Auxilliary Tool: A data structure that represents an image in an efficient memory layout...">ImagePatch</a> objects. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">imagePatches</td><td>Patches to evaluate. </td></tr>
    <tr><td class="paramname">scalarVals</td><td>Result of evaluation, in an STL vector data structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2715c655465e0b91e58d989298e06fe5"></a><!-- doxytag: member="Feature::filterPatchList" ref="a2715c655465e0b91e58d989298e06fe5" args="(PatchList *patches)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Feature::filterPatchList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_patch_list.html">PatchList</a> *&#160;</td>
          <td class="paramname"> <em>patches</em>&#160;)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply the feature to a <a class="el" href="class_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">PatchList</a> data structure. Must be overridden in derived classes. </p>
<p>This is very important for efficiently filtering a whole image. The data for the filtering operation as well as the destination are contained in that data structure. See PatchList.h for details.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">patches</td><td>Remaining patches in a large image to be filtered. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_box_feature.html#aac9b0841615e2a9d066d829a7639570d">BoxFeature</a>.</p>

</div>
</div>
<a class="anchor" id="acf5a29ea61186c95098796c56ca8fc07"></a><!-- doxytag: member="Feature::getFeatureOfSameTypeAndSize" ref="acf5a29ea61186c95098796c56ca8fc07" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_feature.html">Feature</a> * Feature::getFeatureOfSameTypeAndSize </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a feature with same type / dimension as this one, but random parameters. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new feature. </dd></dl>

</div>
</div>
<a class="anchor" id="ae7671cfca735bc2a6e02930d08375657"></a><!-- doxytag: member="Feature::getFeatureOfType" ref="ae7671cfca735bc2a6e02930d08375657" args="(std::string featureName, cv::Size patchSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_feature.html">Feature</a>* Feature::getFeatureOfType </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"> <em>featureName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Size&#160;</td>
          <td class="paramname"> <em>patchSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a subclass based on its name. If you subclass <a class="el" href="class_feature.html" title="Auxilliary Tool: A purely virtual class for providing the skeleton for specific features. This allows different features to be manipulated using a common set of tools.">Feature</a>, you are responsible for modifying Feature.cpp to make this function aware of your feature. This function is important for saving the state of features for classifiers. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An object that is a subclass of <a class="el" href="class_feature.html" title="Auxilliary Tool: A purely virtual class for providing the skeleton for specific features. This allows different features to be manipulated using a common set of tools.">Feature</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a2963467d6f8506d86ea26b753df50da4"></a><!-- doxytag: member="Feature::getFeatureVisualization" ref="a2963467d6f8506d86ea26b753df50da4" args="(cv::Mat &amp;dest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Feature::getFeatureVisualization </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>dest</em>&#160;)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a nice visual representation of the feature. </p>
<p>By default, this simply returns the "kernel" protected member variable, which subclasses should set during "setFeatureParameters".</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An image representing the feature in a visual way. </dd></dl>

</div>
</div>
<a class="anchor" id="a44e27612bc6373341c6967b526f51a20"></a><!-- doxytag: member="Feature::getPatchSize" ref="a44e27612bc6373341c6967b526f51a20" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Size Feature::getPatchSize </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the size of patch that is "natural" for this feature. </p>
<p>Generally, features have a basic size. For example, a convolution-based feature has the size of the convolution kernel. Asking the feature to filter an <a class="el" href="class_image_patch.html" title="Auxilliary Tool: A data structure that represents an image in an efficient memory layout...">ImagePatch</a> that does not match this size may result in degraded performance.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Preferred patch size. </dd></dl>

</div>
</div>
<a class="anchor" id="a7f0f2f2605e7cf9a227b8ac3547ad97b"></a><!-- doxytag: member="Feature::getSimilarFeatures" ref="a7f0f2f2605e7cf9a227b8ac3547ad97b" args="(int numFeatures=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_feature.html">Feature</a> * &gt; Feature::getSimilarFeatures </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>numFeatures</em> = <code>1</code>&#160;)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get features similar to the current feature. This is useful for searching through feature space for local optima. </p>
<p>By default, this randomly mutates the elements of the feature parameter vector. Override this function if different behavior is desired.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">numFeatures</td><td>Number of nearby features to grab.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Set of nearby features. </dd></dl>

</div>
</div>
<a class="anchor" id="a2e8f002043690e2bd6b8c0b45ba3a70e"></a><!-- doxytag: member="Feature::setFeatureParameters" ref="a2e8f002043690e2bd6b8c0b45ba3a70e" args="(const cv::Mat &amp;paramVec)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Feature::setFeatureParameters </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>paramVec</em>&#160;)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Basic feature initialization. Must be overridden in derived classes. </p>
<p>Subclasses should be able to completely reinitialize their own member variables from their parameter vector. This allows us to save a parameter vector to disk and then reconstruct the feature later.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">paramVec</td><td>A set of values sufficient to reconstruct a feature, or to construct a new one automatically. Must have type CV_64FC1 </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_box_feature.html#a1e4592eab39da1d01027c71db75b8f7c">BoxFeature</a>, and <a class="el" href="class_haar_feature.html#a5bb8e92b51b93812beb59b2c7399c504">HaarFeature</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/nick/projects/NickThesis/Code/OpenCV/src/Feature.h</li>
<li>/Users/nick/projects/NickThesis/Code/OpenCV/src/Feature.cpp</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Dec 9 2010 16:05:48 for Nick's Machine Perception Toolbox by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
