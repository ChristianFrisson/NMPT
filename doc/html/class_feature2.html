<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Nick&#39;s Machine Perception Toolbox: Feature2 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>Feature2 Class Reference<br/>
<small>
[<a class="el" href="group___aux_group.html">Auxilliary Tools</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="Feature2" -->
<p><code>Auxilliary Tool:</code> A purely virtual class for providing the skeleton for specific features. This allows different features to be manipulated using a common set of tools.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;Feature2.h&gt;</code></p>
<!-- startSectionHeader --><div class="dynheader">
Inheritance diagram for Feature2:<!-- endSectionHeader --></div>
<!-- startSectionSummary --><!-- endSectionSummary --><!-- startSectionContent --><div class="dyncontent">
<div class="center"><img src="class_feature2__inherit__graph.png" border="0" usemap="#_feature2_inherit__map" alt="Inheritance graph"/></div>
<map name="_feature2_inherit__map" id="_feature2_inherit__map">
<area shape="rect" id="node3" href="class_box_feature2.html" title="Auxilliary Tool: A linear feature that uses the &quot;Integral &#160;Image&quot; trick to efficiently eval..." alt="" coords="9,83,111,112"/><area shape="rect" id="node5" href="class_haar_feature2.html" title="Auxilliary Tool: A linear feature that uses Haar Wavelets, which are a certain kind of box filter..." alt="" coords="5,160,115,189"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center><!-- endSectionContent --></div>

<p><a href="class_feature2-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature2.html#ab2a4a00a9d5957c67f8e621ea9a7e144">evaluateImagePatch</a> (const <a class="el" href="class_image_patch2.html">ImagePatch2</a> &amp;patch) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn an <a class="el" href="class_image_patch.html" title="Auxilliary Tool: A data structure that represents an image in an efficient memory layout...">ImagePatch</a> into a scalar value. This is the basic job of any feature.  <a href="#ab2a4a00a9d5957c67f8e621ea9a7e144"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature2.html#ac9934586acc39069fb164489b78312d0">filterPatchList</a> (<a class="el" href="class_patch_list2.html">PatchList2</a> *patches) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the feature to a <a class="el" href="class_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">PatchList</a> data structure. Must be overridden in derived classes.  <a href="#ac9934586acc39069fb164489b78312d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature2.html#ad93339a2a423e537f83498e14493e15e">setFeatureParameters</a> (const cv::Mat &amp;paramVec)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic feature initialization. Must be overridden in derived classes.  <a href="#ad93339a2a423e537f83498e14493e15e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="class_feature2.html">Feature2</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature2.html#a6feb35eca720f93f9849925c28796c58">getSimilarFeatures</a> (int numFeatures=1) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get features similar to the current feature. This is useful for searching through feature space for local optima.  <a href="#a6feb35eca720f93f9849925c28796c58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature2.html#af8a6cae580d32031ef3d3385f99544f7">getFeatureVisualization</a> (cv::Mat &amp;dest) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a nice visual representation of the feature.  <a href="#af8a6cae580d32031ef3d3385f99544f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature2.html#a370b9621a82087cb28bfeb22bef056bd">debugInfo</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints information about this feature for help debugging. By default, this prints the feature type, and its parameters.  <a href="#a370b9621a82087cb28bfeb22bef056bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53584a25982f23b9c71659a163ac1ff4"></a><!-- doxytag: member="Feature2::~Feature2" ref="a53584a25982f23b9c71659a163ac1ff4" args="()" -->
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature2.html#a53584a25982f23b9c71659a163ac1ff4">~Feature2</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. By default, this cleans up the parameters, valid parameter ranges, kernel image, and name. Subclasses are responsible for cleaning up extra memory. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature2.html#abbd5333b1b03d907b5ea387ad0290a31">writeToFile</a> (cv::FileStorage &amp;storage, const std::string &amp;varname) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Archive to cv::FileStorage,.  <a href="#abbd5333b1b03d907b5ea387ad0290a31"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_feature2.html">Feature2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature2.html#a7a7d76145e673193e7a62ed342c7b001">getFeatureOfSameTypeAndSize</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a feature with same type / dimension as this one, but random parameters.  <a href="#a7a7d76145e673193e7a62ed342c7b001"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_feature2.html">Feature2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature2.html#a4490e39b27158442752a5c59d68c76c2">copy</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a feature with the same type / dimension / parameters as this one.  <a href="#a4490e39b27158442752a5c59d68c76c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature2.html#aac016b05ee2af8c3ef3b5a597f97feb1">evaluateImagePatches</a> (const std::vector&lt; <a class="el" href="class_image_patch2.html">ImagePatch2</a> &gt; &amp;imagePatches, cv::Mat &amp;scalarVals) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply feature to multiple <a class="el" href="class_image_patch.html" title="Auxilliary Tool: A data structure that represents an image in an efficient memory layout...">ImagePatch</a> objects.  <a href="#aac016b05ee2af8c3ef3b5a597f97feb1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cv::Size&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature2.html#a50944a7dc0e7fb9732a9938091c2f1f8">getPatchSize</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of patch that is "natural" for this feature.  <a href="#a50944a7dc0e7fb9732a9938091c2f1f8"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_feature2.html">Feature2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature2.html#a16cb9f6c8176bd758bc8c8c7b8ba34ae">getFeatureOfType</a> (std::string featureName, cv::Size patchSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a subclass based on its name. If you subclass <a class="el" href="class_feature.html" title="Auxilliary Tool: A purely virtual class for providing the skeleton for specific features. This allows different features to be manipulated using a common set of tools.">Feature</a>, you are responsible for modifying Feature.cpp to make this function aware of your feature. This function is important for saving the state of features for classifiers.  <a href="#a16cb9f6c8176bd758bc8c8c7b8ba34ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_feature2.html">Feature2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature2.html#a4b75f16f3a3c528fd17bde807ec47124">readFromFile</a> (const cv::FileNode &amp;storage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unarchive from cv::FileStorage, when saved using writeToFile.  <a href="#a4b75f16f3a3c528fd17bde807ec47124"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d4f80334b641cec944ac4dddb0238e3"></a><!-- doxytag: member="Feature2::operator&lt;&lt;" ref="a0d4f80334b641cec944ac4dddb0238e3" args="(std::ostream &amp;ofs, const Feature2 *feat)" -->
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature2.html#a0d4f80334b641cec944ac4dddb0238e3">operator&lt;&lt;</a> (std::ostream &amp;ofs, const <a class="el" href="class_feature2.html">Feature2</a> *feat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to a file. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc1a6bfdb63ec12e153daeb8214ba074"></a><!-- doxytag: member="Feature2::operator&gt;&gt;" ref="acc1a6bfdb63ec12e153daeb8214ba074" args="(std::istream &amp;ifs, Feature2 *&amp;feat)" -->
std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature2.html#acc1a6bfdb63ec12e153daeb8214ba074">operator&gt;&gt;</a> (std::istream &amp;ifs, <a class="el" href="class_feature2.html">Feature2</a> *&amp;feat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from a file. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><code>Auxilliary Tool:</code> A purely virtual class for providing the skeleton for specific features. This allows different features to be manipulated using a common set of tools. </p>
<p>In general, we conceive of a feature as something that takes an image patch as input, and produces a scalar output. It may be necessary at times for a feature to apply itself efficiently to multiple image patches, using the <a class="el" href="class_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">PatchList</a> data structure. Also, it will be necessary to find features similar to this one, and may be convenient to represent a feature in a compact parameterized form. Thus, a feature should implement the following:</p>
<p>virtual double evaluateImagePatch(const ImagePatch* patch); virtual void filterPatchList( PatchList* patches); virtual void setFeatureParameters(const CvMat* paramVec);</p>
<p>Additionally, the following utilities are provided but may be overridden:</p>
<p>virtual vector&lt;Feature*&gt; getSimilarFeatures(int numFeatures); virtual IplImage* visualizeFeature(); virtual string <a class="el" href="class_feature2.html#a370b9621a82087cb28bfeb22bef056bd" title="Prints information about this feature for help debugging. By default, this prints the feature type...">debugInfo() const</a>; virtual ~Feature();</p>
<p>NOTE ON SUBCLASSING: In order for everything to work properly, a few rules need to be followed. First, subclasses should be able to completely reinitialize their own member variables from their parameter vector. This allows us to save a parameter vector to disk and then reconstruct the feature later. Second, subclasses should set the protected "featureName" variable, which helps determine which what the actual type of a saved feature is. Third (finally), Feature.cpp's getFeatureOfType method must be modified to be aware of your feature class, by calling the correct constructor (your constructor) when a feature of your type is read from disk.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>Nicholas Butko </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>2010 </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>0.4 </dd></dl>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a4490e39b27158442752a5c59d68c76c2"></a><!-- doxytag: member="Feature2::copy" ref="a4490e39b27158442752a5c59d68c76c2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_feature2.html">Feature2</a> * Feature2::copy </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a feature with the same type / dimension / parameters as this one. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new feature. </dd></dl>

</div>
</div>
<a class="anchor" id="a370b9621a82087cb28bfeb22bef056bd"></a><!-- doxytag: member="Feature2::debugInfo" ref="a370b9621a82087cb28bfeb22bef056bd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string Feature2::debugInfo </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints information about this feature for help debugging. By default, this prints the feature type, and its parameters. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Information about this feature useful for debugging. </dd></dl>

</div>
</div>
<a class="anchor" id="ab2a4a00a9d5957c67f8e621ea9a7e144"></a><!-- doxytag: member="Feature2::evaluateImagePatch" ref="ab2a4a00a9d5957c67f8e621ea9a7e144" args="(const ImagePatch2 &amp;patch) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double Feature2::evaluateImagePatch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_image_patch2.html">ImagePatch2</a> &amp;&#160;</td>
          <td class="paramname"> <em>patch</em>&#160;)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Turn an <a class="el" href="class_image_patch.html" title="Auxilliary Tool: A data structure that represents an image in an efficient memory layout...">ImagePatch</a> into a scalar value. This is the basic job of any feature. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">patch</td><td>The image patch to evaluate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value of the Image Patch according to the feature. </dd></dl>

<p>Implemented in <a class="el" href="class_box_feature2.html#a0fbe6d77bdbe487b340020997ab4f94c">BoxFeature2</a>.</p>

</div>
</div>
<a class="anchor" id="aac016b05ee2af8c3ef3b5a597f97feb1"></a><!-- doxytag: member="Feature2::evaluateImagePatches" ref="aac016b05ee2af8c3ef3b5a597f97feb1" args="(const std::vector&lt; ImagePatch2 &gt; &amp;imagePatches, cv::Mat &amp;scalarVals) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Feature2::evaluateImagePatches </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_image_patch2.html">ImagePatch2</a> &gt; &amp;&#160;</td>
          <td class="paramname"> <em>imagePatches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>scalarVals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply feature to multiple <a class="el" href="class_image_patch.html" title="Auxilliary Tool: A data structure that represents an image in an efficient memory layout...">ImagePatch</a> objects. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">imagePatches</td><td>Patches to evaluate. </td></tr>
    <tr><td class="paramname">scalarVals</td><td>Result of evaluation, in a CvMat data structure. If the provided CvMat is NULL or has inappropriate size, it will be freed and recreated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac9934586acc39069fb164489b78312d0"></a><!-- doxytag: member="Feature2::filterPatchList" ref="ac9934586acc39069fb164489b78312d0" args="(PatchList2 *patches) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Feature2::filterPatchList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_patch_list2.html">PatchList2</a> *&#160;</td>
          <td class="paramname"> <em>patches</em>&#160;)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply the feature to a <a class="el" href="class_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">PatchList</a> data structure. Must be overridden in derived classes. </p>
<p>This is very important for efficiently filtering a whole image. The data for the filtering operation as well as the destination are contained in that data structure. See PatchList.h for details.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">patches</td><td>Remaining patches in a large image to be filtered. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_box_feature2.html#a1b5c8efb61149b995f7c79b2d5e8ae9d">BoxFeature2</a>.</p>

</div>
</div>
<a class="anchor" id="a7a7d76145e673193e7a62ed342c7b001"></a><!-- doxytag: member="Feature2::getFeatureOfSameTypeAndSize" ref="a7a7d76145e673193e7a62ed342c7b001" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_feature2.html">Feature2</a> * Feature2::getFeatureOfSameTypeAndSize </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a feature with same type / dimension as this one, but random parameters. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A new feature. </dd></dl>

</div>
</div>
<a class="anchor" id="a16cb9f6c8176bd758bc8c8c7b8ba34ae"></a><!-- doxytag: member="Feature2::getFeatureOfType" ref="a16cb9f6c8176bd758bc8c8c7b8ba34ae" args="(std::string featureName, cv::Size patchSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_feature2.html">Feature2</a>* Feature2::getFeatureOfType </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"> <em>featureName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Size&#160;</td>
          <td class="paramname"> <em>patchSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a subclass based on its name. If you subclass <a class="el" href="class_feature.html" title="Auxilliary Tool: A purely virtual class for providing the skeleton for specific features. This allows different features to be manipulated using a common set of tools.">Feature</a>, you are responsible for modifying Feature.cpp to make this function aware of your feature. This function is important for saving the state of features for classifiers. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An object that is a subclass of <a class="el" href="class_feature.html" title="Auxilliary Tool: A purely virtual class for providing the skeleton for specific features. This allows different features to be manipulated using a common set of tools.">Feature</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="af8a6cae580d32031ef3d3385f99544f7"></a><!-- doxytag: member="Feature2::getFeatureVisualization" ref="af8a6cae580d32031ef3d3385f99544f7" args="(cv::Mat &amp;dest) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Feature2::getFeatureVisualization </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>dest</em>&#160;)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a nice visual representation of the feature. </p>
<p>By default, this simply returns the "kernel" protected member variable, which subclasses should set during "setFeatureParameters".</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An image representing the feature in a visual way. </dd></dl>

</div>
</div>
<a class="anchor" id="a50944a7dc0e7fb9732a9938091c2f1f8"></a><!-- doxytag: member="Feature2::getPatchSize" ref="a50944a7dc0e7fb9732a9938091c2f1f8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Size Feature2::getPatchSize </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the size of patch that is "natural" for this feature. </p>
<p>Generally, features have a basic size. For example, a convolution-based feature has the size of the convolution kernel. Asking the feature to filter an <a class="el" href="class_image_patch.html" title="Auxilliary Tool: A data structure that represents an image in an efficient memory layout...">ImagePatch</a> that does not match this size may result in degraded performance.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Preferred patch size. </dd></dl>

</div>
</div>
<a class="anchor" id="a6feb35eca720f93f9849925c28796c58"></a><!-- doxytag: member="Feature2::getSimilarFeatures" ref="a6feb35eca720f93f9849925c28796c58" args="(int numFeatures=1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_feature2.html">Feature2</a> * &gt; Feature2::getSimilarFeatures </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>numFeatures</em> = <code>1</code>&#160;)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get features similar to the current feature. This is useful for searching through feature space for local optima. </p>
<p>By default, this randomly mutates the elements of the feature parameter vector. Override this function if different behavior is desired.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">numFeatures</td><td>Number of nearby features to grab.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Set of nearby features. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b75f16f3a3c528fd17bde807ec47124"></a><!-- doxytag: member="Feature2::readFromFile" ref="a4b75f16f3a3c528fd17bde807ec47124" args="(const cv::FileNode &amp;storage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_feature2.html">Feature2</a> * Feature2::readFromFile </td>
          <td>(</td>
          <td class="paramtype">const cv::FileNode &amp;&#160;</td>
          <td class="paramname"> <em>storage</em>&#160;)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unarchive from cv::FileStorage, when saved using writeToFile. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An object that is a subclass of <a class="el" href="class_feature.html" title="Auxilliary Tool: A purely virtual class for providing the skeleton for specific features. This allows different features to be manipulated using a common set of tools.">Feature</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad93339a2a423e537f83498e14493e15e"></a><!-- doxytag: member="Feature2::setFeatureParameters" ref="ad93339a2a423e537f83498e14493e15e" args="(const cv::Mat &amp;paramVec)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Feature2::setFeatureParameters </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>paramVec</em>&#160;)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Basic feature initialization. Must be overridden in derived classes. </p>
<p>Subclasses should be able to completely reinitialize their own member variables from their parameter vector. This allows us to save a parameter vector to disk and then reconstruct the feature later.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">paramVec</td><td>A set of values sufficient to reconstruct a feature, or to construct a new one automatically. Must have type CV_64FC1 </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_box_feature2.html#adda199544889ce47bac362bffefe81d9">BoxFeature2</a>, and <a class="el" href="class_haar_feature2.html#abd289c85f66070a5b26648ef4e6ced3a">HaarFeature2</a>.</p>

</div>
</div>
<a class="anchor" id="abbd5333b1b03d907b5ea387ad0290a31"></a><!-- doxytag: member="Feature2::writeToFile" ref="abbd5333b1b03d907b5ea387ad0290a31" args="(cv::FileStorage &amp;storage, const std::string &amp;varname) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Feature2::writeToFile </td>
          <td>(</td>
          <td class="paramtype">cv::FileStorage &amp;&#160;</td>
          <td class="paramname"> <em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"> <em>varname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Archive to cv::FileStorage,. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">storage</td><td>An instance of cv::FileStorage that is open for writing.</td></tr>
    <tr><td class="paramname">varname</td><td>Name used as a key for unarchiving. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/nick/projects/NickThesis/Code/OpenCV/src/Feature2.h</li>
<li>/Users/nick/projects/NickThesis/Code/OpenCV/src/Feature2.cpp</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Dec 9 2010 16:05:48 for Nick's Machine Perception Toolbox by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
