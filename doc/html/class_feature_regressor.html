<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Nick&#39;s Machine Perception Toolbox: FeatureRegressor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>FeatureRegressor Class Reference<br/>
<small>
[<a class="el" href="group___aux_group.html">Auxilliary Tools</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="FeatureRegressor" -->
<p><code>Auxilliary Tool:</code> A data structure that learns a non-linear tuning curve for mapping feature outputs to image labels. This is the "weak learner" used by GentleBoost.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;FeatureRegressor.h&gt;</code></p>
<!-- startSectionHeader --><div class="dynheader">
Collaboration diagram for FeatureRegressor:<!-- endSectionHeader --></div>
<!-- startSectionSummary --><!-- endSectionSummary --><!-- startSectionContent --><div class="dyncontent">
<div class="center"><img src="class_feature_regressor__coll__graph.png" border="0" usemap="#_feature_regressor_coll__map" alt="Collaboration graph"/></div>
<map name="_feature_regressor_coll__map" id="_feature_regressor_coll__map">
<area shape="rect" id="node2" href="class_feature.html" title="Auxilliary Tool: A purely virtual class for providing the skeleton for specific features. This allows different features to be manipulated using a common set of tools." alt="" coords="37,5,107,35"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center><!-- endSectionContent --></div>

<p><a href="class_feature_regressor-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56372dcb4947d0cc0e2a549126121e0b"></a><!-- doxytag: member="FeatureRegressor::FeatureRegressor" ref="a56372dcb4947d0cc0e2a549126121e0b" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature_regressor.html#a56372dcb4947d0cc0e2a549126121e0b">FeatureRegressor</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e6b713fd6b58ccc73e3b11a0ab6ca98"></a><!-- doxytag: member="FeatureRegressor::setFeature" ref="a7e6b713fd6b58ccc73e3b11a0ab6ca98" args="(const Feature *feature)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature_regressor.html#a7e6b713fd6b58ccc73e3b11a0ab6ca98">setFeature</a> (const <a class="el" href="class_feature.html">Feature</a> *feature)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set feature. Must call train again after setting feature. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature_regressor.html#adfebf221b1b043ccf21621da5e5a92f2">FeatureRegressor</a> (const <a class="el" href="class_feature.html">Feature</a> *feature)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#adfebf221b1b043ccf21621da5e5a92f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63789e2b29e3b27290140d49f3b03aa2"></a><!-- doxytag: member="FeatureRegressor::~FeatureRegressor" ref="a63789e2b29e3b27290140d49f3b03aa2" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature_regressor.html#a63789e2b29e3b27290140d49f3b03aa2">~FeatureRegressor</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96d9c40bd0ef0e3de839b32e5421cb8a"></a><!-- doxytag: member="FeatureRegressor::FeatureRegressor" ref="a96d9c40bd0ef0e3de839b32e5421cb8a" args="(const FeatureRegressor &amp;copy)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature_regressor.html#a96d9c40bd0ef0e3de839b32e5421cb8a">FeatureRegressor</a> (const <a class="el" href="class_feature_regressor.html">FeatureRegressor</a> &amp;copy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy Constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29fcb7c10082f7b2b3e0c784a5bfc132"></a><!-- doxytag: member="FeatureRegressor::operator=" ref="a29fcb7c10082f7b2b3e0c784a5bfc132" args="(const FeatureRegressor &amp;rhs)" -->
<a class="el" href="class_feature_regressor.html">FeatureRegressor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature_regressor.html#a29fcb7c10082f7b2b3e0c784a5bfc132">operator=</a> (const <a class="el" href="class_feature_regressor.html">FeatureRegressor</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature_regressor.html#a2f7c466132fe7d97a79af9099fa604f2">train</a> (int numTableElements, const std::vector&lt; <a class="el" href="class_image_patch.html">ImagePatch</a> * &gt; &amp;patches, const cv::Mat &amp;labels, const cv::Mat &amp;dataWeights)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Train the regression model with data.  <a href="#a2f7c466132fe7d97a79af9099fa604f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature_regressor.html#aec3190799a0edbc9116dd3e1b57a887c">train</a> (int numTableElements, const std::vector&lt; <a class="el" href="class_image_patch.html">ImagePatch</a> &gt; &amp;patches, const cv::Mat &amp;labels, const cv::Mat &amp;dataWeights)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Train the regression model with data.  <a href="#aec3190799a0edbc9116dd3e1b57a887c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature_regressor.html#aad9b43a3f912026e0b28d96ba67fc531">predict</a> (const std::vector&lt; <a class="el" href="class_image_patch.html">ImagePatch</a> &gt; patches, cv::Mat &amp;scalarVals) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to predict whether new <a class="el" href="class_image_patch.html" title="Auxilliary Tool: A data structure that represents an image in an efficient memory layout...">ImagePatch</a> data are the object we're trying to detect.  <a href="#aad9b43a3f912026e0b28d96ba67fc531"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature_regressor.html#a0e2248989886f878f8ca685f548b9607">predict</a> (const std::vector&lt; <a class="el" href="class_image_patch.html">ImagePatch</a> * &gt; patches, cv::Mat &amp;scalarVals) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to predict whether new <a class="el" href="class_image_patch.html" title="Auxilliary Tool: A data structure that represents an image in an efficient memory layout...">ImagePatch</a> data are the object we're trying to detect.  <a href="#a0e2248989886f878f8ca685f548b9607"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature_regressor.html#a093decf376eb063a00ef167047de6db4">predict</a> (const std::vector&lt; <a class="el" href="class_image_patch.html">ImagePatch</a> &gt; &amp;patches, std::vector&lt; double &gt; &amp;scalarVals) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to predict whether new <a class="el" href="class_image_patch.html" title="Auxilliary Tool: A data structure that represents an image in an efficient memory layout...">ImagePatch</a> data are the object we're trying to detect.  <a href="#a093decf376eb063a00ef167047de6db4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature_regressor.html#a83ad43a9a76d11a1c145ca3598c7daea">predict</a> (const std::vector&lt; <a class="el" href="class_image_patch.html">ImagePatch</a> * &gt; &amp;patches, std::vector&lt; double &gt; &amp;scalarVals) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to predict whether new <a class="el" href="class_image_patch.html" title="Auxilliary Tool: A data structure that represents an image in an efficient memory layout...">ImagePatch</a> data are the object we're trying to detect.  <a href="#a83ad43a9a76d11a1c145ca3598c7daea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature_regressor.html#a23ae7219058d903f0cebea582cc1b86f">predictPatchList</a> (<a class="el" href="class_patch_list.html">PatchList</a> *patches) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to predict whether a set of patches corresponding to image locations are the object. This is used for efficiently searching through a whole image for the object.  <a href="#a23ae7219058d903f0cebea582cc1b86f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature_regressor.html#ae6e9f474a4158cf56e84e4885c933132">applyLUTToImage</a> (cv::Mat &amp;image) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming all patches in an image were filtered with the feature, this will make a prediction for each pixel as to whether it is the top left corner of the trained object. Modifies the input image.  <a href="#ae6e9f474a4158cf56e84e4885c933132"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature_regressor.html#a81c5f2f5d45b7756747481a2ba4f84a3">combineLUTs</a> (const <a class="el" href="class_feature_regressor.html">FeatureRegressor</a> *other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine predictions from two regressors. This can be used to "boost" the confidence of a single feature in a computationally efficient way.  <a href="#a81c5f2f5d45b7756747481a2ba4f84a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature_regressor.html#a3ba7d7aa7c2c281bad959385d0c8847e">combineLUTs</a> (const <a class="el" href="class_feature_regressor.html">FeatureRegressor</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine predictions from two regressors. This can be used to "boost" the confidence of a single feature in a computationally efficient way.  <a href="#a3ba7d7aa7c2c281bad959385d0c8847e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature_regressor.html#a3c5ec13f7745b1351e7e5614c8db54e2">getLUTRange</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the range of feature values computed during training (max-min). This can be useful for detecting degenerate features that produce extremely small ranges of values.  <a href="#a3c5ec13f7745b1351e7e5614c8db54e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_feature.html">Feature</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature_regressor.html#a48204e7d415b771536080643d9184013">getFeature</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the feature that this <a class="el" href="class_feature_regressor.html" title="Auxilliary Tool: A data structure that learns a non-linear tuning curve for mapping feature outputs t...">FeatureRegressor</a> was created with. This returns the actual feature object used by the regressor, which is a copy of the one it was trained with.  <a href="#a48204e7d415b771536080643d9184013"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cv::Size&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature_regressor.html#aab0d090d31003dd910adf8e75d70bbd2">getFeaturePatchSize</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the patch size of the FeatureRegressor's <a class="el" href="class_feature.html" title="Auxilliary Tool: A purely virtual class for providing the skeleton for specific features. This allows different features to be manipulated using a common set of tools.">Feature</a>.  <a href="#aab0d090d31003dd910adf8e75d70bbd2"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature_regressor.html#a1c33ebf798ccda0b2982b05580078a13">TAU</a> = .05</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Window-Size regularization Parameter.  <a href="#a1c33ebf798ccda0b2982b05580078a13"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature_regressor.html#a2e0a007967b5c45ec6bee36f4228f8d2">EPS</a> = .001</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">No-Evidence regularization Parameter.  <a href="#a2e0a007967b5c45ec6bee36f4228f8d2"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e6f3492bb74ec101956086d0814f1b3"></a><!-- doxytag: member="FeatureRegressor::operator&lt;&lt;" ref="a3e6f3492bb74ec101956086d0814f1b3" args="(std::ostream &amp;ofs, const FeatureRegressor *reg)" -->
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature_regressor.html#a3e6f3492bb74ec101956086d0814f1b3">operator&lt;&lt;</a> (std::ostream &amp;ofs, const <a class="el" href="class_feature_regressor.html">FeatureRegressor</a> *reg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to a file. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd7ae911d29fc8edea33a8ff23591945"></a><!-- doxytag: member="FeatureRegressor::operator&lt;&lt;" ref="afd7ae911d29fc8edea33a8ff23591945" args="(std::ostream &amp;ofs, const FeatureRegressor &amp;reg)" -->
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature_regressor.html#afd7ae911d29fc8edea33a8ff23591945">operator&lt;&lt;</a> (std::ostream &amp;ofs, const <a class="el" href="class_feature_regressor.html">FeatureRegressor</a> &amp;reg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to a file. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d51a7275b44e49ebad7ae0f6fffd7b6"></a><!-- doxytag: member="FeatureRegressor::operator&gt;&gt;" ref="a7d51a7275b44e49ebad7ae0f6fffd7b6" args="(std::istream &amp;ifs, FeatureRegressor *&amp;reg)" -->
std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature_regressor.html#a7d51a7275b44e49ebad7ae0f6fffd7b6">operator&gt;&gt;</a> (std::istream &amp;ifs, <a class="el" href="class_feature_regressor.html">FeatureRegressor</a> *&amp;reg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from a file. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76ced25db52c48df454701a00671cc9c"></a><!-- doxytag: member="FeatureRegressor::operator&gt;&gt;" ref="a76ced25db52c48df454701a00671cc9c" args="(std::istream &amp;ifs, FeatureRegressor &amp;reg)" -->
std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_feature_regressor.html#a76ced25db52c48df454701a00671cc9c">operator&gt;&gt;</a> (std::istream &amp;ifs, <a class="el" href="class_feature_regressor.html">FeatureRegressor</a> &amp;reg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from a file. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><code>Auxilliary Tool:</code> A data structure that learns a non-linear tuning curve for mapping feature outputs to image labels. This is the "weak learner" used by GentleBoost. </p>
<p>A <a class="el" href="class_feature_regressor.html" title="Auxilliary Tool: A data structure that learns a non-linear tuning curve for mapping feature outputs t...">FeatureRegressor</a> is initialized with a feature. It must then be trained, using a set of image patches, labels indicating whether the image patches are positive or negative examples (-1 for negative, +1 for positive), and weights for each example, which specify how much the learner should care about getting the answer of that example correct, relative to the other examples.</p>
<p>Two regularization parameters control the behavior of the feature regressor: TAU describes the window-of-influence of each example, and can range from (0-1], with a default of 0.05. EPS describes what happens in regions with no data. If EPS is high, the classifier will revert to the mean label in regions with no data. If EPS is 0, the classifier will use the label of the nearest point. The default is 0.001. Since these are regularization parameters, it doesn't make sense to tune them on an individual basis. Therefore, they are static variables.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>Nicholas Butko </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>2010 </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>0.4 </dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="adfebf221b1b043ccf21621da5e5a92f2"></a><!-- doxytag: member="FeatureRegressor::FeatureRegressor" ref="adfebf221b1b043ccf21621da5e5a92f2" args="(const Feature *feature)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FeatureRegressor::FeatureRegressor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_feature.html">Feature</a> *&#160;</td>
          <td class="paramname"> <em>feature</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">feature</td><td>The feature that transforms <a class="el" href="class_image_patch.html" title="Auxilliary Tool: A data structure that represents an image in an efficient memory layout...">ImagePatch</a> data into a scalar value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae6e9f474a4158cf56e84e4885c933132"></a><!-- doxytag: member="FeatureRegressor::applyLUTToImage" ref="ae6e9f474a4158cf56e84e4885c933132" args="(cv::Mat &amp;image) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FeatureRegressor::applyLUTToImage </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>image</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assuming all patches in an image were filtered with the feature, this will make a prediction for each pixel as to whether it is the top left corner of the trained object. Modifies the input image. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Precondition: contains the filter outputs at each point in the image. Postcondition: contains the prediction (in -1:1) about whether the top-left of the object is located at each pixel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a81c5f2f5d45b7756747481a2ba4f84a3"></a><!-- doxytag: member="FeatureRegressor::combineLUTs" ref="a81c5f2f5d45b7756747481a2ba4f84a3" args="(const FeatureRegressor *other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FeatureRegressor::combineLUTs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_feature_regressor.html">FeatureRegressor</a> *&#160;</td>
          <td class="paramname"> <em>other</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Combine predictions from two regressors. This can be used to "boost" the confidence of a single feature in a computationally efficient way. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another <a class="el" href="class_feature_regressor.html" title="Auxilliary Tool: A data structure that learns a non-linear tuning curve for mapping feature outputs t...">FeatureRegressor</a>, trained with either different data, or a different weighting, but that has the same base feature. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3ba7d7aa7c2c281bad959385d0c8847e"></a><!-- doxytag: member="FeatureRegressor::combineLUTs" ref="a3ba7d7aa7c2c281bad959385d0c8847e" args="(const FeatureRegressor &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FeatureRegressor::combineLUTs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_feature_regressor.html">FeatureRegressor</a> &amp;&#160;</td>
          <td class="paramname"> <em>other</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Combine predictions from two regressors. This can be used to "boost" the confidence of a single feature in a computationally efficient way. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another <a class="el" href="class_feature_regressor.html" title="Auxilliary Tool: A data structure that learns a non-linear tuning curve for mapping feature outputs t...">FeatureRegressor</a>, trained with either different data, or a different weighting, but that has the same base feature. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a48204e7d415b771536080643d9184013"></a><!-- doxytag: member="FeatureRegressor::getFeature" ref="a48204e7d415b771536080643d9184013" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_feature.html">Feature</a> * FeatureRegressor::getFeature </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the feature that this <a class="el" href="class_feature_regressor.html" title="Auxilliary Tool: A data structure that learns a non-linear tuning curve for mapping feature outputs t...">FeatureRegressor</a> was created with. This returns the actual feature object used by the regressor, which is a copy of the one it was trained with. </p>
<p>return The actual feature object of the regressor. </p>

</div>
</div>
<a class="anchor" id="aab0d090d31003dd910adf8e75d70bbd2"></a><!-- doxytag: member="FeatureRegressor::getFeaturePatchSize" ref="aab0d090d31003dd910adf8e75d70bbd2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Size FeatureRegressor::getFeaturePatchSize </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the patch size of the FeatureRegressor's <a class="el" href="class_feature.html" title="Auxilliary Tool: A purely virtual class for providing the skeleton for specific features. This allows different features to be manipulated using a common set of tools.">Feature</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Base patch size for this regressor. </dd></dl>

</div>
</div>
<a class="anchor" id="a3c5ec13f7745b1351e7e5614c8db54e2"></a><!-- doxytag: member="FeatureRegressor::getLUTRange" ref="a3c5ec13f7745b1351e7e5614c8db54e2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double FeatureRegressor::getLUTRange </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the range of feature values computed during training (max-min). This can be useful for detecting degenerate features that produce extremely small ranges of values. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The range of feature values computed during training (max-min). </dd></dl>

</div>
</div>
<a class="anchor" id="aad9b43a3f912026e0b28d96ba67fc531"></a><!-- doxytag: member="FeatureRegressor::predict" ref="aad9b43a3f912026e0b28d96ba67fc531" args="(const std::vector&lt; ImagePatch &gt; patches, cv::Mat &amp;scalarVals) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FeatureRegressor::predict </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_image_patch.html">ImagePatch</a> &gt;&#160;</td>
          <td class="paramname"> <em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>scalarVals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Try to predict whether new <a class="el" href="class_image_patch.html" title="Auxilliary Tool: A data structure that represents an image in an efficient memory layout...">ImagePatch</a> data are the object we're trying to detect. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">patches</td><td>The image patches that are or are not examples of the class of interest.</td></tr>
    <tr><td class="paramname">scalarVals</td><td>A graded confidence that the patch is or is not the object of interest (set by the algorithm), ranging from +1 (sure that it is the object) through 0 (completely unsure) to -1 (sure that it's not an instance of the object). If the provided CvMat is NULL or has inappropriate size, it will be freed and recreated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a83ad43a9a76d11a1c145ca3598c7daea"></a><!-- doxytag: member="FeatureRegressor::predict" ref="a83ad43a9a76d11a1c145ca3598c7daea" args="(const std::vector&lt; ImagePatch * &gt; &amp;patches, std::vector&lt; double &gt; &amp;scalarVals) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FeatureRegressor::predict </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_image_patch.html">ImagePatch</a> * &gt; &amp;&#160;</td>
          <td class="paramname"> <em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"> <em>scalarVals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Try to predict whether new <a class="el" href="class_image_patch.html" title="Auxilliary Tool: A data structure that represents an image in an efficient memory layout...">ImagePatch</a> data are the object we're trying to detect. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">patches</td><td>The image patches that are or are not examples of the class of interest.</td></tr>
    <tr><td class="paramname">scalarVals</td><td>A graded confidence that the patch is or is not the object of interest (set by the algorithm), ranging from +1 (sure that it is the object) through 0 (completely unsure) to -1 (sure that it's not an instance of the object) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a093decf376eb063a00ef167047de6db4"></a><!-- doxytag: member="FeatureRegressor::predict" ref="a093decf376eb063a00ef167047de6db4" args="(const std::vector&lt; ImagePatch &gt; &amp;patches, std::vector&lt; double &gt; &amp;scalarVals) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FeatureRegressor::predict </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_image_patch.html">ImagePatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"> <em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"> <em>scalarVals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Try to predict whether new <a class="el" href="class_image_patch.html" title="Auxilliary Tool: A data structure that represents an image in an efficient memory layout...">ImagePatch</a> data are the object we're trying to detect. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">patches</td><td>The image patches that are or are not examples of the class of interest.</td></tr>
    <tr><td class="paramname">scalarVals</td><td>A graded confidence that the patch is or is not the object of interest (set by the algorithm), ranging from +1 (sure that it is the object) through 0 (completely unsure) to -1 (sure that it's not an instance of the object) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0e2248989886f878f8ca685f548b9607"></a><!-- doxytag: member="FeatureRegressor::predict" ref="a0e2248989886f878f8ca685f548b9607" args="(const std::vector&lt; ImagePatch * &gt; patches, cv::Mat &amp;scalarVals) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FeatureRegressor::predict </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_image_patch.html">ImagePatch</a> * &gt;&#160;</td>
          <td class="paramname"> <em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>scalarVals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Try to predict whether new <a class="el" href="class_image_patch.html" title="Auxilliary Tool: A data structure that represents an image in an efficient memory layout...">ImagePatch</a> data are the object we're trying to detect. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">patches</td><td>The image patches that are or are not examples of the class of interest.</td></tr>
    <tr><td class="paramname">scalarVals</td><td>A graded confidence that the patch is or is not the object of interest (set by the algorithm), ranging from +1 (sure that it is the object) through 0 (completely unsure) to -1 (sure that it's not an instance of the object). If the provided CvMat is NULL or has inappropriate size, it will be freed and recreated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a23ae7219058d903f0cebea582cc1b86f"></a><!-- doxytag: member="FeatureRegressor::predictPatchList" ref="a23ae7219058d903f0cebea582cc1b86f" args="(PatchList *patches) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FeatureRegressor::predictPatchList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_patch_list.html">PatchList</a> *&#160;</td>
          <td class="paramname"> <em>patches</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Try to predict whether a set of patches corresponding to image locations are the object. This is used for efficiently searching through a whole image for the object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">patches</td><td>Candidate locations in the image where it is thought the object may be. The results are stored in the <a class="el" href="class_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">PatchList</a> data structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f7c466132fe7d97a79af9099fa604f2"></a><!-- doxytag: member="FeatureRegressor::train" ref="a2f7c466132fe7d97a79af9099fa604f2" args="(int numTableElements, const std::vector&lt; ImagePatch * &gt; &amp;patches, const cv::Mat &amp;labels, const cv::Mat &amp;dataWeights)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FeatureRegressor::train </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>numTableElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_image_patch.html">ImagePatch</a> * &gt; &amp;&#160;</td>
          <td class="paramname"> <em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>dataWeights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Train the regression model with data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">numTableElements</td><td>The learned tuning curve is discretized into a number of discrete bins, based on the range of feature outputs observed in training. A reasonable number of bins is 100.</td></tr>
    <tr><td class="paramname">patches</td><td>The image patches that are or are not examples of the class of interest.</td></tr>
    <tr><td class="paramname">labels</td><td>Labels indicating whether each patch is or isn't the object we're trying to detect, +1 means yes, -1 means no.</td></tr>
    <tr><td class="paramname">dataWeights</td><td>Specify how much the learner should care about getting the answer of that example correct, relative to the other examples. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec3190799a0edbc9116dd3e1b57a887c"></a><!-- doxytag: member="FeatureRegressor::train" ref="aec3190799a0edbc9116dd3e1b57a887c" args="(int numTableElements, const std::vector&lt; ImagePatch &gt; &amp;patches, const cv::Mat &amp;labels, const cv::Mat &amp;dataWeights)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FeatureRegressor::train </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>numTableElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_image_patch.html">ImagePatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"> <em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>dataWeights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Train the regression model with data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">numTableElements</td><td>The learned tuning curve is discretized into a number of discrete bins, based on the range of feature outputs observed in training. A reasonable number of bins is 100.</td></tr>
    <tr><td class="paramname">patches</td><td>The image patches that are or are not examples of the class of interest.</td></tr>
    <tr><td class="paramname">labels</td><td>Labels indicating whether each patch is or isn't the object we're trying to detect, +1 means yes, -1 means no.</td></tr>
    <tr><td class="paramname">dataWeights</td><td>Specify how much the learner should care about getting the answer of that example correct, relative to the other examples. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a2e0a007967b5c45ec6bee36f4228f8d2"></a><!-- doxytag: member="FeatureRegressor::EPS" ref="a2e0a007967b5c45ec6bee36f4228f8d2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_feature_regressor.html#a2e0a007967b5c45ec6bee36f4228f8d2">FeatureRegressor::EPS</a> = .001<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>No-Evidence regularization Parameter. </p>
<p>EPS describes what happens in regions with no data. If EPS is high, the classifier will revert to the mean label in regions with no data. If EPS is 0, the classifier will use the label of the nearest point. The default is 0.001. </p>

</div>
</div>
<a class="anchor" id="a1c33ebf798ccda0b2982b05580078a13"></a><!-- doxytag: member="FeatureRegressor::TAU" ref="a1c33ebf798ccda0b2982b05580078a13" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_feature_regressor.html#a1c33ebf798ccda0b2982b05580078a13">FeatureRegressor::TAU</a> = .05<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Window-Size regularization Parameter. </p>
<p>TAU describes the window-of-influence of each example, and can range from (0-1], with a default of 0.05. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/nick/projects/NickThesis/Code/OpenCV/src/FeatureRegressor.h</li>
<li>/Users/nick/projects/NickThesis/Code/OpenCV/src/FeatureRegressor.cpp</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Dec 9 2010 16:05:48 for Nick's Machine Perception Toolbox by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
