<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Nick&#39;s Machine Perception Toolbox: GentleBoostCascadedClassifier Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>GentleBoostCascadedClassifier Class Reference<br/>
<small>
[<a class="el" href="group___m_p_group.html">Machine Perception Primitives</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="GentleBoostCascadedClassifier" --><!-- doxytag: inherits="GentleBoostClassifier" -->
<p><code> <b> Machine Perception Primitive: </b> </code> An implementation of a GentleBoost cascaded classifier for full image object search.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;GentleBoostCascadedClassifier.h&gt;</code></p>
<!-- startSectionHeader --><div class="dynheader">
Inheritance diagram for GentleBoostCascadedClassifier:<!-- endSectionHeader --></div>
<!-- startSectionSummary --><!-- endSectionSummary --><!-- startSectionContent --><div class="dyncontent">
<div class="center"><img src="class_gentle_boost_cascaded_classifier__inherit__graph.png" border="0" usemap="#_gentle_boost_cascaded_classifier_inherit__map" alt="Inheritance graph"/></div>
<map name="_gentle_boost_cascaded_classifier_inherit__map" id="_gentle_boost_cascaded_classifier_inherit__map">
<area shape="rect" id="node2" href="class_gentle_boost_classifier.html" title=" &#160;Machine Perception Primitive: &#160;&#160;An implementation of a GentleBoost classifier for image patch class..." alt="" coords="37,5,195,35"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center><!-- endSectionContent --></div>
<!-- startSectionHeader --><div class="dynheader">
Collaboration diagram for GentleBoostCascadedClassifier:<!-- endSectionHeader --></div>
<!-- startSectionSummary --><!-- endSectionSummary --><!-- startSectionContent --><div class="dyncontent">
<div class="center"><img src="class_gentle_boost_cascaded_classifier__coll__graph.png" border="0" usemap="#_gentle_boost_cascaded_classifier_coll__map" alt="Collaboration graph"/></div>
<map name="_gentle_boost_cascaded_classifier_coll__map" id="_gentle_boost_cascaded_classifier_coll__map">
<area shape="rect" id="node2" href="class_gentle_boost_classifier.html" title=" &#160;Machine Perception Primitive: &#160;&#160;An implementation of a GentleBoost classifier for image patch class..." alt="" coords="5,120,163,149"/><area shape="rect" id="node4" href="class_image_data_set.html" title="Auxilliary Tool: A data structure for maintaining a list of image files and image labels to facilitat..." alt="" coords="172,5,287,35"/><area shape="rect" id="node6" href="class_patch_dataset.html" title="Auxilliary Tool: A tool for managing the data used in training GentleBoost classifiers." alt="" coords="351,120,460,149"/><area shape="rect" id="node9" href="class_detection_evaluator.html" title="Auxilliary Tool: A tool for evaluating the performance of a whole&#45;image&#45;object&#45;detector, such as a GentleBoostCascadedClassifier, for performance on an ImageDataSet." alt="" coords="328,5,472,35"/><area shape="rect" id="node11" href="class_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ..." alt="" coords="496,5,576,35"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center><!-- endSectionContent --></div>

<p><a href="class_gentle_boost_cascaded_classifier-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1ad06cbb4eb2379398fc474a211620b"></a><!-- doxytag: member="GentleBoostCascadedClassifier::GentleBoostCascadedClassifier" ref="ac1ad06cbb4eb2379398fc474a211620b" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gentle_boost_cascaded_classifier.html#ac1ad06cbb4eb2379398fc474a211620b">GentleBoostCascadedClassifier</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6a1e0e0745f3bd5bfac8061f3ca969f"></a><!-- doxytag: member="GentleBoostCascadedClassifier::~GentleBoostCascadedClassifier" ref="aa6a1e0e0745f3bd5bfac8061f3ca969f" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gentle_boost_cascaded_classifier.html#aa6a1e0e0745f3bd5bfac8061f3ca969f">~GentleBoostCascadedClassifier</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gentle_boost_cascaded_classifier.html#a2f3613ba632b3759f47c7c249affa305">setSearchParams</a> (int useFast=0, cv::Size minSize=cv::Size(0, 0), cv::Size maxSize=cv::Size(0, 0), double scaleInc=1.2, double stepWidth=1, int scaleStepWidth=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set parameters affecting how <a class="el" href="class_gentle_boost_cascaded_classifier.html" title="  Machine Perception Primitive:   An implementation of a GentleBoost cascaded classifier for full ima...">GentleBoostCascadedClassifier</a> searches through images for objects.  <a href="#a2f3613ba632b3759f47c7c249affa305"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gentle_boost_cascaded_classifier.html#af3bd562f835f7ea448ddca5cd7694418">searchImage</a> (const cv::Mat &amp;gray_image, std::vector&lt; <a class="el" href="struct_search_result.html">SearchResult</a> &gt; &amp;keptPatches, int NMSRadius=0, double thresh=-INFINITY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Search through and image for objects that this classifier was trained to detect. Results are passed back via the <a class="el" href="struct_search_result.html" title="Auxilliary Tool: A data structure that keeps track of where objects were detected in the image...">SearchResult</a> vector keptPatches.  <a href="#af3bd562f835f7ea448ddca5cd7694418"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gentle_boost_cascaded_classifier.html#a3d8330aeaae9e333c6f64b596071ce9d">setCurrentImage</a> (const cv::Mat &amp;gray_image)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current image to search, without actually searching. This allows you to search each scale (size) separately and manually, using <a class="el" href="class_gentle_boost_cascaded_classifier.html#adf0495dac360d345c240b1048fa14ee0" title="Search through and image for objects at a single scale (size).">searchCurrentImageAtScale()</a>.  <a href="#a3d8330aeaae9e333c6f64b596071ce9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gentle_boost_cascaded_classifier.html#adf0495dac360d345c240b1048fa14ee0">searchCurrentImageAtScale</a> (std::vector&lt; <a class="el" href="struct_search_result.html">SearchResult</a> &gt; &amp;keptPatches, int scale, int NMSRadius=0, double thresh=-INFINITY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Search through and image for objects at a single scale (size).  <a href="#adf0495dac360d345c240b1048fa14ee0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gentle_boost_cascaded_classifier.html#a824a0b42fa7138e628611c59f97dca59">getNumScales</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the number of scales available for searching for objects. See <a class="el" href="class_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">PatchList</a> for further discussion.  <a href="#a824a0b42fa7138e628611c59f97dca59"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cv::Size&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gentle_boost_cascaded_classifier.html#afd72305ecd6c78dce3e42b124ccf4a08">getSizeOfScale</a> (int scale)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the size of object searched for at a given scale. See <a class="el" href="class_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">PatchList</a> for further discussion.  <a href="#afd72305ecd6c78dce3e42b124ccf4a08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gentle_boost_cascaded_classifier.html#a8d3e70a60ce8ba95df4a31e411806ead">searchPatches</a> (const std::vector&lt; <a class="el" href="class_image_patch.html">ImagePatch</a> * &gt; &amp;patches, const cv::Mat &amp;labels, cv::Mat &amp;survived, cv::Mat &amp;featureSum, cv::Mat &amp;posterior, cv::Mat &amp;predictions, std::vector&lt; cv::Mat &gt; &amp;featureOutputs, double &amp;perf, cv::Mat &amp;weights)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the GentleBoostCascadedClasssifier to a classify collection of image patches.  <a href="#a8d3e70a60ce8ba95df4a31e411806ead"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gentle_boost_cascaded_classifier.html#aed0bd0b066bfaed3cfd1e7d9f40f4181">setTrainingParams</a> (double maxPosRejects=0.001, double desiredNegRejects=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set parameters used to determine the rejection threshold for each cascade step.  <a href="#aed0bd0b066bfaed3cfd1e7d9f40f4181"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_performance_metrics.html">PerformanceMetrics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gentle_boost_cascaded_classifier.html#afb7a07fb1ffeb7a9f500d4151b002ae5">trainOneRound</a> (int patience=1, int boostRounds=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Train boosted classifier for one round by searching for one good feature, and adding it.  <a href="#afb7a07fb1ffeb7a9f500d4151b002ae5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_feature.html">Feature</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gentle_boost_cascaded_classifier.html#a776c975706a981678fe2777ed3455894">getGoodFeature</a> (int patience=1, std::string featureType=&quot;HaarFeature&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Look for a feature that would improve classifier performance.  <a href="#a776c975706a981678fe2777ed3455894"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gentle_boost_cascaded_classifier.html#ae0c2b10e95358a70e8b4a12e14430083">addFeature</a> (<a class="el" href="class_feature.html">Feature</a> *nextFeature)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a feature to the classifier.  <a href="#ae0c2b10e95358a70e8b4a12e14430083"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gentle_boost_cascaded_classifier.html#adfd40865b79e1e1eaa75a9fcd81c4c3d">setTrainingSet</a> (const std::vector&lt; <a class="el" href="class_image_patch.html">ImagePatch</a> * &gt; &amp;trainingPatches, const cv::Mat &amp;trainingLabels)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <a class="el" href="class_image_patch.html" title="Auxilliary Tool: A data structure that represents an image in an efficient memory layout...">ImagePatch</a> data and labels used for training the classifier.  <a href="#adfd40865b79e1e1eaa75a9fcd81c4c3d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gentle_boost_cascaded_classifier.html#af97c88a5940931bfce1e8a100d9fe3bd">setTestingSet</a> (const std::vector&lt; <a class="el" href="class_image_patch.html">ImagePatch</a> * &gt; &amp;testingPatches, const cv::Mat &amp;testingLabels)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <a class="el" href="class_image_patch.html" title="Auxilliary Tool: A data structure that represents an image in an efficient memory layout...">ImagePatch</a> data and labels used for evaluating the classifier.  <a href="#af97c88a5940931bfce1e8a100d9fe3bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gentle_boost_cascaded_classifier.html#a50890800c53af5e9780eebe2b75b7509">setBGTrainingFromImageDataset</a> (const std::string &amp;datasetFileName)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a large collection of images known not have the object you are learning a detector for. These will serve as a source of training data. Only a portion of these will be used for training at a time. Call setHardNegativeExamplesFromBGImages() to swap out patches currently used for training ones for harder ones from the background image pool.  <a href="#a50890800c53af5e9780eebe2b75b7509"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a631ba0444182e849e3a215827adc519d"></a><!-- doxytag: member="GentleBoostCascadedClassifier::setHardNegativeTrainingExamplesFromBGImages" ref="a631ba0444182e849e3a215827adc519d" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gentle_boost_cascaded_classifier.html#a631ba0444182e849e3a215827adc519d">setHardNegativeTrainingExamplesFromBGImages</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the rejected negative example patches in the current training set with patches in taken from background images that haven't yet been rejected. The background image pool is specified with setBGTrainingImagesFromImageDataset(). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0879a4dfaca0fa195e48e5e6bad3ed59"></a><!-- doxytag: member="GentleBoostCascadedClassifier::setHardNegativeTrainingExamplesFromPatches" ref="a0879a4dfaca0fa195e48e5e6bad3ed59" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gentle_boost_cascaded_classifier.html#a0879a4dfaca0fa195e48e5e6bad3ed59">setHardNegativeTrainingExamplesFromPatches</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the rejected negative example patches in the current training set with patches in taken from a pool of background patches yet been rejected. The negative patch pool is specified with setBGTrainingPatches(). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ec6a263efee0b8b93b023b16cb3f0c2"></a><!-- doxytag: member="GentleBoostCascadedClassifier::exhaustedAllNegPatches" ref="a3ec6a263efee0b8b93b023b16cb3f0c2" args="()" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gentle_boost_cascaded_classifier.html#a3ec6a263efee0b8b93b023b16cb3f0c2">exhaustedAllNegPatches</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns "yes" if all known negative patches have been rejected. This is a good time to stop training. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gentle_boost_cascaded_classifier.html#a1abc19109792f832c7f3c965fa857466">addFeatureBoosted</a> (<a class="el" href="class_feature.html">Feature</a> *nextFeature, int boostRounds)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a feature to the classifier by applying multiple rounds of boosting.  <a href="#a1abc19109792f832c7f3c965fa857466"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gentle_boost_cascaded_classifier.html#a85783b06a3d65e60314708f32a5381df">getProbabilityMap</a> (cv::Mat &amp;dest, <a class="el" href="class_patch_list.html">PatchList</a> *patches)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate every pixel in an image for its probability that an object is located there.  <a href="#a85783b06a3d65e60314708f32a5381df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gentle_boost_cascaded_classifier.html#abb19c72043f93c7a63756e05c0c28819">getPerformanceMeasures</a> (<a class="el" href="class_feature.html">Feature</a> *candidate, double &amp;chiSq, int &amp;posRejects, int &amp;negRejects)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute perfomance measures for this classifier, depending on the Feature* passed in. This is primarily used for finding the best feature to add to the classifier, using <a class="el" href="class_gentle_boost_cascaded_classifier.html#ae0c2b10e95358a70e8b4a12e14430083" title="Add a feature to the classifier.">addFeature()</a>.  <a href="#abb19c72043f93c7a63756e05c0c28819"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gentle_boost_cascaded_classifier.html#a22bc9e856a235f143c237c2663de5289">getPerformanceMeasures</a> (const <a class="el" href="class_feature.html">Feature</a> *candidate, <a class="el" href="struct_performance_metrics.html">PerformanceMetrics</a> &amp;perf)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute perfomance measures for this classifier, depending on the Feature* passed in. This is primarily used for finding the best feature to add to the classifier, using <a class="el" href="class_gentle_boost_cascaded_classifier.html#ae0c2b10e95358a70e8b4a12e14430083" title="Add a feature to the classifier.">addFeature()</a>.  <a href="#a22bc9e856a235f143c237c2663de5289"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1341ce64154e65c200c74e62ff042d0"></a><!-- doxytag: member="GentleBoostCascadedClassifier::getNumNegPatches" ref="af1341ce64154e65c200c74e62ff042d0" args="()" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gentle_boost_cascaded_classifier.html#af1341ce64154e65c200c74e62ff042d0">getNumNegPatches</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of negative patches currently being used to train the classifier. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11dc8431d0e6a779710a58f17dfb3489"></a><!-- doxytag: member="GentleBoostCascadedClassifier::getNumPosPatches" ref="a11dc8431d0e6a779710a58f17dfb3489" args="()" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gentle_boost_cascaded_classifier.html#a11dc8431d0e6a779710a58f17dfb3489">getNumPosPatches</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of positive patches currently being used to train the classifier. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gentle_boost_cascaded_classifier.html#a389482641f3ee3ce5ed6e1feab45d849">getImageHeaderForNegPatch</a> (cv::Mat &amp;dst, int patchNum)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an IplImage for visualizing the negative patches in the classifier - This must be released using cvReleaseImageHeader, and not cvReleaseImage, or you will destroy the data used for training.  <a href="#a389482641f3ee3ce5ed6e1feab45d849"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gentle_boost_cascaded_classifier.html#abec7889cae3bb3c16fea728095aabd79">getImageHeaderForPosPatch</a> (cv::Mat &amp;dst, int patchNum)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an IplImage for visualizing the positive patches in the classifier - This must be released using cvReleaseImageHeader, and not cvReleaseImage, or you will destroy the data used for training.  <a href="#abec7889cae3bb3c16fea728095aabd79"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gentle_boost_cascaded_classifier.html#a6a2220819b4ed468d05fc479ee967a36">sharePatchListWithClassifier</a> (<a class="el" href="class_gentle_boost_cascaded_classifier.html">GentleBoostCascadedClassifier</a> *otherClassifier)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Share the patch list of another <a class="el" href="class_gentle_boost_cascaded_classifier.html" title="  Machine Perception Primitive:   An implementation of a GentleBoost cascaded classifier for full ima...">GentleBoostCascadedClassifier</a>, to increase efficiency of multiple classifiers processing the same image.  <a href="#a6a2220819b4ed468d05fc479ee967a36"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a3233feb70ecd506aa2a32e7a24b4bf"></a><!-- doxytag: member="GentleBoostCascadedClassifier::operator&lt;&lt;" ref="a8a3233feb70ecd506aa2a32e7a24b4bf" args="(std::ostream &amp;ofs, GentleBoostCascadedClassifier *booster)" -->
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gentle_boost_cascaded_classifier.html#a8a3233feb70ecd506aa2a32e7a24b4bf">operator&lt;&lt;</a> (std::ostream &amp;ofs, <a class="el" href="class_gentle_boost_cascaded_classifier.html">GentleBoostCascadedClassifier</a> *booster)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to a file. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1dcf1338527fb315cc60bd6f5f1fa2ec"></a><!-- doxytag: member="GentleBoostCascadedClassifier::operator&gt;&gt;" ref="a1dcf1338527fb315cc60bd6f5f1fa2ec" args="(std::istream &amp;ifs, GentleBoostCascadedClassifier *&amp;booster)" -->
std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gentle_boost_cascaded_classifier.html#a1dcf1338527fb315cc60bd6f5f1fa2ec">operator&gt;&gt;</a> (std::istream &amp;ifs, <a class="el" href="class_gentle_boost_cascaded_classifier.html">GentleBoostCascadedClassifier</a> *&amp;booster)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from a file. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><code> <b> Machine Perception Primitive: </b> </code> An implementation of a GentleBoost cascaded classifier for full image object search. </p>
<p>The GentleBoost approach is described in Fasel's "Learning Real-Time Object 
 Detectors: Probabilistic Generative Approaches", 2006 (see <a class="el" href="bib_page.html#bib_sec">Related Publications</a>).</p>
<p><a class="el" href="class_gentle_boost_cascaded_classifier.html" title="  Machine Perception Primitive:   An implementation of a GentleBoost cascaded classifier for full ima...">GentleBoostCascadedClassifier</a> is designed for full frame object detection.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>Nicholas Butko </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>2010 version 0.4 </dd></dl>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae0c2b10e95358a70e8b4a12e14430083"></a><!-- doxytag: member="GentleBoostCascadedClassifier::addFeature" ref="ae0c2b10e95358a70e8b4a12e14430083" args="(Feature *nextFeature)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GentleBoostCascadedClassifier::addFeature </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_feature.html">Feature</a> *&#160;</td>
          <td class="paramname"> <em>nextFeature</em>&#160;)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a feature to the classifier. </p>
<p>This will create a <a class="el" href="class_feature_regressor.html" title="Auxilliary Tool: A data structure that learns a non-linear tuning curve for mapping feature outputs t...">FeatureRegressor</a> and compute its tuning curve based on the current weighting of the training examples, and then reweight the training examples according to the GentleBoost algorithm.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nextFeature</td><td>The feature to add. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_gentle_boost_classifier.html#aca070216162334b2dc770c7b367ad170">GentleBoostClassifier</a>.</p>

</div>
</div>
<a class="anchor" id="a1abc19109792f832c7f3c965fa857466"></a><!-- doxytag: member="GentleBoostCascadedClassifier::addFeatureBoosted" ref="a1abc19109792f832c7f3c965fa857466" args="(Feature *nextFeature, int boostRounds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GentleBoostCascadedClassifier::addFeatureBoosted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_feature.html">Feature</a> *&#160;</td>
          <td class="paramname"> <em>nextFeature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>boostRounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a feature to the classifier by applying multiple rounds of boosting. </p>
<p>This allows a single feature to have more discriminative power, with the danger of overfitting.</p>
<p>The classification result is equivalent to calling <a class="el" href="class_gentle_boost_cascaded_classifier.html#ae0c2b10e95358a70e8b4a12e14430083" title="Add a feature to the classifier.">addFeature()</a> multiple times on the same feature, but leads to greater computational efficiency of the overall classifier.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">nextFeature</td><td>The feature to add. </td></tr>
    <tr><td class="paramname">boostRounds</td><td>Number of times to (effectively) call addFeature on this feature. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a776c975706a981678fe2777ed3455894"></a><!-- doxytag: member="GentleBoostCascadedClassifier::getGoodFeature" ref="a776c975706a981678fe2777ed3455894" args="(int patience=1, std::string featureType=&quot;HaarFeature&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_feature.html">Feature</a>* GentleBoostCascadedClassifier::getGoodFeature </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>patience</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"> <em>featureType</em> = <code>&quot;HaarFeature&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Look for a feature that would improve classifier performance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">patience</td><td>How long do you want to wait to find a good feature?</td></tr>
    <tr><td class="paramname">featureType</td><td>Type of feature to look for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a389482641f3ee3ce5ed6e1feab45d849"></a><!-- doxytag: member="GentleBoostCascadedClassifier::getImageHeaderForNegPatch" ref="a389482641f3ee3ce5ed6e1feab45d849" args="(cv::Mat &amp;dst, int patchNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GentleBoostCascadedClassifier::getImageHeaderForNegPatch </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>patchNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get an IplImage for visualizing the negative patches in the classifier - This must be released using cvReleaseImageHeader, and not cvReleaseImage, or you will destroy the data used for training. </p>
<p>This is useful for, for example, seeing what negative examples are currently confusing the classifier.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">patchNum</td><td>Must be between 0 and <a class="el" href="class_gentle_boost_cascaded_classifier.html#af1341ce64154e65c200c74e62ff042d0" title="Total number of negative patches currently being used to train the classifier.">getNumNegPatches()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An IplImage pointing to the actual training data. Memory must be managed by calling cvReleaseImageHeader, rather than cvReleaseImage(). </dd></dl>

</div>
</div>
<a class="anchor" id="abec7889cae3bb3c16fea728095aabd79"></a><!-- doxytag: member="GentleBoostCascadedClassifier::getImageHeaderForPosPatch" ref="abec7889cae3bb3c16fea728095aabd79" args="(cv::Mat &amp;dst, int patchNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GentleBoostCascadedClassifier::getImageHeaderForPosPatch </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>patchNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get an IplImage for visualizing the positive patches in the classifier - This must be released using cvReleaseImageHeader, and not cvReleaseImage, or you will destroy the data used for training. </p>
<p>This is useful for, for example, seeing what positive examples are currently confusing the classifier.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">patchNum</td><td>Must be between 0 and <a class="el" href="class_gentle_boost_cascaded_classifier.html#a11dc8431d0e6a779710a58f17dfb3489" title="Total number of positive patches currently being used to train the classifier.">getNumPosPatches()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An IplImage pointing to the actual training data. Memory must be managed by calling cvReleaseImageHeader, rather than cvReleaseImage(). </dd></dl>

</div>
</div>
<a class="anchor" id="a824a0b42fa7138e628611c59f97dca59"></a><!-- doxytag: member="GentleBoostCascadedClassifier::getNumScales" ref="a824a0b42fa7138e628611c59f97dca59" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GentleBoostCascadedClassifier::getNumScales </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Query the number of scales available for searching for objects. See <a class="el" href="class_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">PatchList</a> for further discussion. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of scales available for searching objects. </dd></dl>

</div>
</div>
<a class="anchor" id="abb19c72043f93c7a63756e05c0c28819"></a><!-- doxytag: member="GentleBoostCascadedClassifier::getPerformanceMeasures" ref="abb19c72043f93c7a63756e05c0c28819" args="(Feature *candidate, double &amp;chiSq, int &amp;posRejects, int &amp;negRejects)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GentleBoostCascadedClassifier::getPerformanceMeasures </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_feature.html">Feature</a> *&#160;</td>
          <td class="paramname"> <em>candidate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"> <em>chiSq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"> <em>posRejects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"> <em>negRejects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute perfomance measures for this classifier, depending on the Feature* passed in. This is primarily used for finding the best feature to add to the classifier, using <a class="el" href="class_gentle_boost_cascaded_classifier.html#ae0c2b10e95358a70e8b4a12e14430083" title="Add a feature to the classifier.">addFeature()</a>. </p>
<p>getPerformanceMeasures has three modes depending on the candidate feature: </p>
<ul>
<li>If the feature is NULL, calculates the current chi-squared error </li>
<li>If the feature is currently in the classifier, calculates the error if we remove the feature </li>
<li>Otherwise, calculates the error if we were to add this feature.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">candidate</td><td>Can be NULL, one of the features in the classifier, or a candidate feature to add to the classifier.</td></tr>
    <tr><td class="paramname">chiSq</td><td>The computed error measure (lower is better). </td></tr>
    <tr><td class="paramname">posRejects</td><td>The number of positive examples rejected by adding this feature (lower is better). </td></tr>
    <tr><td class="paramname">negRejects</td><td>The number of negative examples rejected by adding this feature (higher is better). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a22bc9e856a235f143c237c2663de5289"></a><!-- doxytag: member="GentleBoostCascadedClassifier::getPerformanceMeasures" ref="a22bc9e856a235f143c237c2663de5289" args="(const Feature *candidate, PerformanceMetrics &amp;perf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GentleBoostCascadedClassifier::getPerformanceMeasures </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_feature.html">Feature</a> *&#160;</td>
          <td class="paramname"> <em>candidate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_performance_metrics.html">PerformanceMetrics</a> &amp;&#160;</td>
          <td class="paramname"> <em>perf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute perfomance measures for this classifier, depending on the Feature* passed in. This is primarily used for finding the best feature to add to the classifier, using <a class="el" href="class_gentle_boost_cascaded_classifier.html#ae0c2b10e95358a70e8b4a12e14430083" title="Add a feature to the classifier.">addFeature()</a>. </p>
<p>getPerformanceMeasures has three modes depending on the candidate feature: </p>
<ul>
<li>If the feature is NULL, calculates the current chi-squared error </li>
<li>If the feature is currently in the classifier, calculates the error if we remove the feature </li>
<li>Otherwise, calculates the error if we were to add this feature.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">candidate</td><td>Can be NULL, one of the features in the classifier, or a candidate feature to add to the classifier.</td></tr>
    <tr><td class="paramname">perf</td><td>Metrics of performance. See <a class="el" href="struct_performance_metrics.html" title="Auxilliary Tool: A data structure that keeps track of how a classifier (specifically a cascaded class...">PerformanceMetrics</a> documentation for further reference. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a85783b06a3d65e60314708f32a5381df"></a><!-- doxytag: member="GentleBoostCascadedClassifier::getProbabilityMap" ref="a85783b06a3d65e60314708f32a5381df" args="(cv::Mat &amp;dest, PatchList *patches)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GentleBoostCascadedClassifier::getProbabilityMap </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_patch_list.html">PatchList</a> *&#160;</td>
          <td class="paramname"> <em>patches</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate every pixel in an image for its probability that an object is located there. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">patches</td><td>A <a class="el" href="class_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">PatchList</a> that has had setImage() called, and also resetListToScale(). Only the current search scale is evaluated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An image with size patches-&gt;getImageSizeAtScale(), containing probability estimates. Each pixel represents the probability that the image patch with its top-left pixel at that probability map location contains an object. </dd></dl>

</div>
</div>
<a class="anchor" id="afd72305ecd6c78dce3e42b124ccf4a08"></a><!-- doxytag: member="GentleBoostCascadedClassifier::getSizeOfScale" ref="afd72305ecd6c78dce3e42b124ccf4a08" args="(int scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Size GentleBoostCascadedClassifier::getSizeOfScale </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>scale</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Query the size of object searched for at a given scale. See <a class="el" href="class_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">PatchList</a> for further discussion. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>Search scale.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Patch size (object size) searched at that scale. </dd></dl>

</div>
</div>
<a class="anchor" id="adf0495dac360d345c240b1048fa14ee0"></a><!-- doxytag: member="GentleBoostCascadedClassifier::searchCurrentImageAtScale" ref="adf0495dac360d345c240b1048fa14ee0" args="(std::vector&lt; SearchResult &gt; &amp;keptPatches, int scale, int NMSRadius=0, double thresh=&#45;INFINITY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GentleBoostCascadedClassifier::searchCurrentImageAtScale </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_search_result.html">SearchResult</a> &gt; &amp;&#160;</td>
          <td class="paramname"> <em>keptPatches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>NMSRadius</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>thresh</em> = <code>-INFINITY</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Search through and image for objects at a single scale (size). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">keptPatches</td><td>Results of the search are recorded in this vector. This is faster than returning a vector. </td></tr>
    <tr><td class="paramname">scale</td><td>Scale to search at. Must be between 0 and <a class="el" href="class_gentle_boost_cascaded_classifier.html#a824a0b42fa7138e628611c59f97dca59" title="Query the number of scales available for searching for objects. See PatchList for further discussion...">getNumScales()</a>-1. </td></tr>
    <tr><td class="paramname">NMSRadius</td><td>Suppress object detection results if there is a another <a class="el" href="struct_search_result.html" title="Auxilliary Tool: A data structure that keeps track of where objects were detected in the image...">SearchResult</a> with higher value nearby (within radius NMSRadius pixels). </td></tr>
    <tr><td class="paramname">thresh</td><td>Suppress object detection results with a value lower than thresh. Using -INFINITY returns all results. Using thresh=0 returns only <a class="el" href="struct_search_result.html" title="Auxilliary Tool: A data structure that keeps track of where objects were detected in the image...">SearchResult</a> records that the cascade has at least 50% confidence in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af3bd562f835f7ea448ddca5cd7694418"></a><!-- doxytag: member="GentleBoostCascadedClassifier::searchImage" ref="af3bd562f835f7ea448ddca5cd7694418" args="(const cv::Mat &amp;gray_image, std::vector&lt; SearchResult &gt; &amp;keptPatches, int NMSRadius=0, double thresh=&#45;INFINITY)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GentleBoostCascadedClassifier::searchImage </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>gray_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_search_result.html">SearchResult</a> &gt; &amp;&#160;</td>
          <td class="paramname"> <em>keptPatches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>NMSRadius</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>thresh</em> = <code>-INFINITY</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Search through and image for objects that this classifier was trained to detect. Results are passed back via the <a class="el" href="struct_search_result.html" title="Auxilliary Tool: A data structure that keeps track of where objects were detected in the image...">SearchResult</a> vector keptPatches. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gray_image</td><td>Image or Frame to search. Must be single-channel, with depth IPL_DEPTH_8U. </td></tr>
    <tr><td class="paramname">keptPatches</td><td>Results of the search are recorded in this vector. This is faster than returning a vector. </td></tr>
    <tr><td class="paramname">NMSRadius</td><td>Suppress object detection results if there is a another <a class="el" href="struct_search_result.html" title="Auxilliary Tool: A data structure that keeps track of where objects were detected in the image...">SearchResult</a> with higher value nearby (within radius NMSRadius pixels). </td></tr>
    <tr><td class="paramname">thresh</td><td>Suppress object detection results with a value lower than thresh. Using -INFINITY returns all results. Using thresh=0 returns only <a class="el" href="struct_search_result.html" title="Auxilliary Tool: A data structure that keeps track of where objects were detected in the image...">SearchResult</a> records that the cascade has at least 50% confidence in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8d3e70a60ce8ba95df4a31e411806ead"></a><!-- doxytag: member="GentleBoostCascadedClassifier::searchPatches" ref="a8d3e70a60ce8ba95df4a31e411806ead" args="(const std::vector&lt; ImagePatch * &gt; &amp;patches, const cv::Mat &amp;labels, cv::Mat &amp;survived, cv::Mat &amp;featureSum, cv::Mat &amp;posterior, cv::Mat &amp;predictions, std::vector&lt; cv::Mat &gt; &amp;featureOutputs, double &amp;perf, cv::Mat &amp;weights)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GentleBoostCascadedClassifier::searchPatches </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_image_patch.html">ImagePatch</a> * &gt; &amp;&#160;</td>
          <td class="paramname"> <em>patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>survived</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>featureSum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>posterior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>predictions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cv::Mat &gt; &amp;&#160;</td>
          <td class="paramname"> <em>featureOutputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"> <em>perf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply the GentleBoostCascadedClasssifier to a classify collection of image patches. </p>
<p>This classification requires a lot of scratch memory, which you can provide. The behavior of this function depends on which provided pointers are NULL. For example, perf and weights are only computed if labels is not NULL, whereas featureSum, posterior, and predictions are always computed. If any matrices that are required are NULL or incorrectly sized, they will be (re)allocated, and the caller of the function is responsible for managing that memory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">patches</td><td>A list of patches to classify. </td></tr>
    <tr><td class="paramname">labels</td><td>Optional labels for the patches, to evaluate classifier performance. </td></tr>
    <tr><td class="paramname">survived</td><td>Indicates whether or not a patch was rejected before classification finished. If rejected, it is automatically given the label prediction -1, regardless of the posterior. </td></tr>
    <tr><td class="paramname">featureSum</td><td>The accumulated feature output that is used to predict the label of the patch. </td></tr>
    <tr><td class="paramname">posterior</td><td>The probability estimate that the patch was generated by the trained class. </td></tr>
    <tr><td class="paramname">predictions</td><td>Binary (+1/-1) classification labels applied by the classifier. </td></tr>
    <tr><td class="paramname">featureOutputs</td><td>The output of each individual <a class="el" href="class_feature_regressor.html" title="Auxilliary Tool: A data structure that learns a non-linear tuning curve for mapping feature outputs t...">FeatureRegressor</a> applied to each patch. </td></tr>
    <tr><td class="paramname">perf</td><td>Chi-Squared error in predicting labels (only set if labels are provided). </td></tr>
    <tr><td class="paramname">weights</td><td>Weights based on boosting that can be used for training the next feature. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a50890800c53af5e9780eebe2b75b7509"></a><!-- doxytag: member="GentleBoostCascadedClassifier::setBGTrainingFromImageDataset" ref="a50890800c53af5e9780eebe2b75b7509" args="(const std::string &amp;datasetFileName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GentleBoostCascadedClassifier::setBGTrainingFromImageDataset </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"> <em>datasetFileName</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Specify a large collection of images known not have the object you are learning a detector for. These will serve as a source of training data. Only a portion of these will be used for training at a time. Call setHardNegativeExamplesFromBGImages() to swap out patches currently used for training ones for harder ones from the background image pool. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">datasetFileName</td><td>Path to a file containing the paths to images (one per line) known to not contain the detector target. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3d8330aeaae9e333c6f64b596071ce9d"></a><!-- doxytag: member="GentleBoostCascadedClassifier::setCurrentImage" ref="a3d8330aeaae9e333c6f64b596071ce9d" args="(const cv::Mat &amp;gray_image)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GentleBoostCascadedClassifier::setCurrentImage </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>gray_image</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the current image to search, without actually searching. This allows you to search each scale (size) separately and manually, using <a class="el" href="class_gentle_boost_cascaded_classifier.html#adf0495dac360d345c240b1048fa14ee0" title="Search through and image for objects at a single scale (size).">searchCurrentImageAtScale()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gray_image</td><td>Image or Frame to search. Must be single-channel, with depth IPL_DEPTH_8U. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f3613ba632b3759f47c7c249affa305"></a><!-- doxytag: member="GentleBoostCascadedClassifier::setSearchParams" ref="a2f3613ba632b3759f47c7c249affa305" args="(int useFast=0, cv::Size minSize=cv::Size(0, 0), cv::Size maxSize=cv::Size(0, 0), double scaleInc=1.2, double stepWidth=1, int scaleStepWidth=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GentleBoostCascadedClassifier::setSearchParams </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>useFast</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Size&#160;</td>
          <td class="paramname"> <em>minSize</em> = <code>cv::Size(0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Size&#160;</td>
          <td class="paramname"> <em>maxSize</em> = <code>cv::Size(0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>scaleInc</em> = <code>1.2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>stepWidth</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>scaleStepWidth</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set parameters affecting how <a class="el" href="class_gentle_boost_cascaded_classifier.html" title="  Machine Perception Primitive:   An implementation of a GentleBoost cascaded classifier for full ima...">GentleBoostCascadedClassifier</a> searches through images for objects. </p>
<p>These are all parameters that are passed on to a <a class="el" href="class_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">PatchList</a> object. See <a class="el" href="class_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">PatchList</a> documentation for further details.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">useFast</td><td>Use "FastPatchList" rather than "PatchList" for searching. This improves speed, but can significantly hamper detector performance. Using useFast=0 is highly recommended. </td></tr>
    <tr><td class="paramname">minSize</td><td>Don't search for objects smaller than minSize. If minSize is (0,0) then baseObjectSize is used. </td></tr>
    <tr><td class="paramname">maxSize</td><td>Don't search for objects larger than maxSize. If maxSize is (0,0), then the upper bound on the object size is the smallest dimension of the image size. </td></tr>
    <tr><td class="paramname">scaleInc</td><td>Relative size of the object in the next scale, compared to the current one. scaleInc must be greater than 1. </td></tr>
    <tr><td class="paramname">stepWidth</td><td>Search interval between subsequent patches. A stepWidth of 1 means slide the object evaluation window over one pixel. 2 means only evaluate patches at every other pixel. 1.5 means search two and skip the third, etc. </td></tr>
    <tr><td class="paramname">scaleStepWidth</td><td>Only applies if useFast=1. A boolean (0 or non-zero) value, indicating whether the stepWidth should scale up with the patch size. Setting 1 gives the same relative coverage to all scales, setting to 0 gives relatively finer coverage to larger scales, and searching will take considerably more time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af97c88a5940931bfce1e8a100d9fe3bd"></a><!-- doxytag: member="GentleBoostCascadedClassifier::setTestingSet" ref="af97c88a5940931bfce1e8a100d9fe3bd" args="(const std::vector&lt; ImagePatch * &gt; &amp;testingPatches, const cv::Mat &amp;testingLabels)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GentleBoostCascadedClassifier::setTestingSet </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_image_patch.html">ImagePatch</a> * &gt; &amp;&#160;</td>
          <td class="paramname"> <em>testingPatches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>testingLabels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <a class="el" href="class_image_patch.html" title="Auxilliary Tool: A data structure that represents an image in an efficient memory layout...">ImagePatch</a> data and labels used for evaluating the classifier. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">testingPatches</td><td>A collection of positive and negative examples that the classifier's discrimination will be evaluated on.</td></tr>
    <tr><td class="paramname">testingLabels</td><td>Binary (+1/-1) indicating the label of each patch. This should be a matrix of type CV_64FC1 with size numPatches x 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aed0bd0b066bfaed3cfd1e7d9f40f4181"></a><!-- doxytag: member="GentleBoostCascadedClassifier::setTrainingParams" ref="aed0bd0b066bfaed3cfd1e7d9f40f4181" args="(double maxPosRejects=0.001, double desiredNegRejects=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GentleBoostCascadedClassifier::setTrainingParams </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>maxPosRejects</em> = <code>0.001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>desiredNegRejects</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set parameters used to determine the rejection threshold for each cascade step. </p>
<p>The threshold is chosen as soon as more than a fraction maxPosRejects of the remaining positive patches have been rejected, or when a fraction desiredNegRejects of the remaining negative patches have been rejected.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">maxPosRejects</td><td>Max fraction of remaining positive patches rejected per training round. </td></tr>
    <tr><td class="paramname">desiredNegRejects</td><td>Desired fraction of remaining negative patches rejected per training round. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adfd40865b79e1e1eaa75a9fcd81c4c3d"></a><!-- doxytag: member="GentleBoostCascadedClassifier::setTrainingSet" ref="adfd40865b79e1e1eaa75a9fcd81c4c3d" args="(const std::vector&lt; ImagePatch * &gt; &amp;trainingPatches, const cv::Mat &amp;trainingLabels)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GentleBoostCascadedClassifier::setTrainingSet </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_image_patch.html">ImagePatch</a> * &gt; &amp;&#160;</td>
          <td class="paramname"> <em>trainingPatches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>trainingLabels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set <a class="el" href="class_image_patch.html" title="Auxilliary Tool: A data structure that represents an image in an efficient memory layout...">ImagePatch</a> data and labels used for training the classifier. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">trainingPatches</td><td>A collection of positive and negative examples that the classifier should learn to discriminate.</td></tr>
    <tr><td class="paramname">trainingLabels</td><td>Binary (+1/-1) indicating the label of each patch. This should be a matrix of type CV_64FC1 with size numPatches x 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6a2220819b4ed468d05fc479ee967a36"></a><!-- doxytag: member="GentleBoostCascadedClassifier::sharePatchListWithClassifier" ref="a6a2220819b4ed468d05fc479ee967a36" args="(GentleBoostCascadedClassifier *otherClassifier)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GentleBoostCascadedClassifier::sharePatchListWithClassifier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_gentle_boost_cascaded_classifier.html">GentleBoostCascadedClassifier</a> *&#160;</td>
          <td class="paramname"> <em>otherClassifier</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Share the patch list of another <a class="el" href="class_gentle_boost_cascaded_classifier.html" title="  Machine Perception Primitive:   An implementation of a GentleBoost cascaded classifier for full ima...">GentleBoostCascadedClassifier</a>, to increase efficiency of multiple classifiers processing the same image. </p>
<p>By sharing a patch list, calling "setImage" on one classifier will set it for all of them. Thus different classifiers can share processing on the same image data.</p>
<p>However, be careful with this. It cannot be undone (within the lifetime of a single object -- reloading the classifier from disk will undo it).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">otherClassifier</td><td>Classifier to share a <a class="el" href="class_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">PatchList</a> with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb7a07fb1ffeb7a9f500d4151b002ae5"></a><!-- doxytag: member="GentleBoostCascadedClassifier::trainOneRound" ref="afb7a07fb1ffeb7a9f500d4151b002ae5" args="(int patience=1, int boostRounds=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_performance_metrics.html">PerformanceMetrics</a> GentleBoostCascadedClassifier::trainOneRound </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>patience</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>boostRounds</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Train boosted classifier for one round by searching for one good feature, and adding it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">patience</td><td>How long do you want to wait to find a good feature?</td></tr>
    <tr><td class="paramname">boostRounds</td><td>Train for multiple rounds of boosting on one feature: makes the classifier more discriminative but more prone to overfit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/nick/projects/NickThesis/Code/OpenCV/src/GentleBoostCascadedClassifier.h</li>
<li>/Users/nick/projects/NickThesis/Code/OpenCV/src/GentleBoostCascadedClassifier.cpp</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Dec 9 2010 16:05:48 for Nick's Machine Perception Toolbox by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
