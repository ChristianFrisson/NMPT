<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Nick&#39;s Machine Perception Toolbox: ImagePatchPyramid Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>ImagePatchPyramid Class Reference<br/>
<small>
[<a class="el" href="group___aux_group.html">Auxilliary Tools</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="ImagePatchPyramid" -->
<p><code>Auxilliary Tool:</code> The main data structure for the <a class="el" href="class_m_i_p_o_m_d_p.html" title="  Machine Perception Primitive:   An implementation of the &quot;Multinomial IPOMDP&quot; algorithm f...">MIPOMDP</a> algorithm. It is reponsible for generating the <a class="el" href="class_m_i_p_o_m_d_p.html" title="  Machine Perception Primitive:   An implementation of the &quot;Multinomial IPOMDP&quot; algorithm f...">MIPOMDP</a> observation vector. The <a class="el" href="class_image_patch_pyramid.html" title="Auxilliary Tool: The main data structure for the MIPOMDP algorithm. It is reponsible for generating t...">ImagePatchPyramid</a> (IPP) is described in detail in Butko &amp; Movellan 2009 (see <a class="el" href="bib_page.html#bib_sec">Related Publications</a>).  
<a href="#_details">More...</a></p>

<p><code>#include &lt;ImagePatchPyramid.h&gt;</code></p>

<p>Inherited by MOImagePatchPyramid.</p>
<!-- startSectionHeader --><div class="dynheader">
Collaboration diagram for ImagePatchPyramid:<!-- endSectionHeader --></div>
<!-- startSectionSummary --><!-- endSectionSummary --><!-- startSectionContent --><div class="dyncontent">
<div class="center"><img src="class_image_patch_pyramid__coll__graph.png" border="0" usemap="#_image_patch_pyramid_coll__map" alt="Collaboration graph"/></div>
<map name="_image_patch_pyramid_coll__map" id="_image_patch_pyramid_coll__map">
<area shape="rect" id="node2" href="class_open_c_v_haar_detector.html" title="Auxilliary Tool: A specific object detector that uses OpenCV&#39;s Haar Cascade Classifier to detect ..." alt="" coords="5,85,165,115"/><area shape="rect" id="node4" href="class_object_detector.html" title="Auxilliary Tool: A virtual class for providing the skeleton for specific object detectors." alt="" coords="27,5,144,35"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center><!-- endSectionContent --></div>

<p><a href="class_image_patch_pyramid-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_patch_pyramid.html#ab412629f27d09a06b1acbbd736cbe711">ImagePatchPyramid</a> (CvSize inputImageSize, CvSize subImageSize, CvSize gridSize, int numSubImages, CvMat *subImageGridPoints, <a class="el" href="class_open_c_v_haar_detector.html">OpenCVHaarDetector</a> *<a class="el" href="class_image_patch_pyramid.html#ae2c4b6f81c5c567ae07e3167e9aaad6b">detector</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Main Constructor: Manually create an IPP.  <a href="#ab412629f27d09a06b1acbbd736cbe711"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_patch_pyramid.html#a7fe16df82917dd6fc6f059a11094a071">ImagePatchPyramid</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Placeholder Constructor.  <a href="#a7fe16df82917dd6fc6f059a11094a071"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af87034a576d53e7c8fc770c876d52bc5"></a><!-- doxytag: member="ImagePatchPyramid::ImagePatchPyramid" ref="af87034a576d53e7c8fc770c876d52bc5" args="(ImagePatchPyramid *ippToCopy)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_patch_pyramid.html#af87034a576d53e7c8fc770c876d52bc5">ImagePatchPyramid</a> (<a class="el" href="class_image_patch_pyramid.html">ImagePatchPyramid</a> *ippToCopy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep Copy Constructor: Create an IPP that is identical to the one copied. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_patch_pyramid.html#a734ed81add18902c3723c1312354616d">~ImagePatchPyramid</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Destructor.  <a href="#a734ed81add18902c3723c1312354616d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_patch_pyramid.html#aefdbf7e8d423fa3f3539c8be9abd6b3b">searchFrameAtGridPoint</a> (IplImage *grayFrame, CvPoint searchPoint)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The main method for generating an observation vector: given an image, generate a count of object-detector firings in each grid-cell based on a fixation point. After this method is called, the resulting observation is stored in the objectCount element.  <a href="#aefdbf7e8d423fa3f3539c8be9abd6b3b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual CvPoint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_patch_pyramid.html#a0bd72e73795a97189e5ecd6348616a08">searchHighResImage</a> (IplImage *grayFrame)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the object detector to the entire image. This is used for comparing the speed and accuracy of the foveated search strategy. After this method is called, the count of objects that the object detector found in each grid-cell in the high resolution image is stored in objectCount. The location of the object is inferred as being the grid-cell with the highest count.  <a href="#a0bd72e73795a97189e5ecd6348616a08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_patch_pyramid.html#a3cbefc440265f9ce34dee0ee9da9f57f">getNumScales</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of levels that the IP Pyramid has.  <a href="#a3cbefc440265f9ce34dee0ee9da9f57f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_patch_pyramid.html#a1cc5ed7899cd020716b4174ea9aec65f">getUsedScales</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of levels that the IP Pyramid is currently using.  <a href="#a1cc5ed7899cd020716b4174ea9aec65f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee88107bd7fda1a2b434720190fb69c6"></a><!-- doxytag: member="ImagePatchPyramid::getGridCellHeightOfScale" ref="aee88107bd7fda1a2b434720190fb69c6" args="(int i)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_patch_pyramid.html#aee88107bd7fda1a2b434720190fb69c6">getGridCellHeightOfScale</a> (int i)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The height (measured in grid-cells) of the ith largest scale, indexed from 0. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a290e8ba19adc5fee7ccd59d39049eba9"></a><!-- doxytag: member="ImagePatchPyramid::getGridCellWidthOfScale" ref="a290e8ba19adc5fee7ccd59d39049eba9" args="(int i)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_patch_pyramid.html#a290e8ba19adc5fee7ccd59d39049eba9">getGridCellWidthOfScale</a> (int i)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The width (measured in grid-cells) of the ith largest scale, indexed from 0. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CvRect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_patch_pyramid.html#a7fab3f9c5a286e6be1a3987ca5662f38">getVisibleRegion</a> (CvPoint searchPoint)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the region of the belief map that is visible in any scales when fixating a grid-point.  <a href="#a7fab3f9c5a286e6be1a3987ca5662f38"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3fa3b789453cf2ce7b8f3dd5dc355d0"></a><!-- doxytag: member="ImagePatchPyramid::getInputImageSize" ref="ae3fa3b789453cf2ce7b8f3dd5dc355d0" args="()" -->
CvSize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_patch_pyramid.html#ae3fa3b789453cf2ce7b8f3dd5dc355d0">getInputImageSize</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The expected size of the next input image. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CvSize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_patch_pyramid.html#a72e9c15911a6a703f3e810d0d29f0324">getSubImageSize</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The common reference size that image patches are down-scaled to.  <a href="#a72e9c15911a6a703f3e810d0d29f0324"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CvSize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_patch_pyramid.html#a89642bceb1e9d66e63614268ad414e61">getMinSize</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum allowed subImageSize.  <a href="#a89642bceb1e9d66e63614268ad414e61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6bb19e34abfa7ec7319e3cfda3d19b4"></a><!-- doxytag: member="ImagePatchPyramid::gridPointForPixel" ref="aa6bb19e34abfa7ec7319e3cfda3d19b4" args="(CvPoint pixel)" -->
CvPoint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_patch_pyramid.html#aa6bb19e34abfa7ec7319e3cfda3d19b4">gridPointForPixel</a> (CvPoint pixel)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Map a pixel location in the original image into a grid-cell. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea6a9b7c6a773c2074488efb25cc579d"></a><!-- doxytag: member="ImagePatchPyramid::pixelForGridPoint" ref="aea6a9b7c6a773c2074488efb25cc579d" args="(CvPoint gridPoint)" -->
CvPoint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_patch_pyramid.html#aea6a9b7c6a773c2074488efb25cc579d">pixelForGridPoint</a> (CvPoint gridPoint)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the pixel in the original image that is in the center of a grid-cell. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62f8a2a3d53d5f5806a0243d41f63582"></a><!-- doxytag: member="ImagePatchPyramid::getGeneratePreview" ref="a62f8a2a3d53d5f5806a0243d41f63582" args="()" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_patch_pyramid.html#a62f8a2a3d53d5f5806a0243d41f63582">getGeneratePreview</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out if the foveaRepresentation preview image is being set after every fixation. This may be turned off in order to improve efficiency. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_patch_pyramid.html#ad6fcecf811160e9eba874ee1dc2067d6">getSameFrameOptimizations</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether same-frame optimizations are being used.  <a href="#ad6fcecf811160e9eba874ee1dc2067d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_patch_pyramid.html#ae9811241e2b3519a51eb4eaadf174d27">changeInputImageSize</a> (CvSize newInputSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the size of the input image and the downsampled image patches. Omitting a newSubImageSize causes the smallest-used-scale to have a 1-1 pixel mapping with the downsampled image patch -- i.e. information is not lost in the smallest scale.  <a href="#ae9811241e2b3519a51eb4eaadf174d27"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_patch_pyramid.html#a1bf5feb8afc9764e2978e38b0709167f">changeInputImageSize</a> (CvSize newInputSize, CvSize newSubImageSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the size of the input image and the downsampled image patches.  <a href="#a1bf5feb8afc9764e2978e38b0709167f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_patch_pyramid.html#aee6d5f72a851b2a0c7fb5882060fa1d4">setGeneratePreview</a> (int flag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns on/off the code that modifies foveaRepresentation to visualize the process of fixating.  <a href="#aee6d5f72a851b2a0c7fb5882060fa1d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_patch_pyramid.html#af427daa054b3c7be5087f0aaf9ec5a2a">setMinSize</a> (CvSize minsize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the minimum allowed subImageSize.  <a href="#af427daa054b3c7be5087f0aaf9ec5a2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_patch_pyramid.html#a28f8eba799e27a05af28ef0ec150da91">setNewImage</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell the IPP not to use the next-frame optimizations for the next frame.  <a href="#a28f8eba799e27a05af28ef0ec150da91"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_patch_pyramid.html#a71f7fdf4416eef2225b275c30867f8a3">useSameFrameOptimizations</a> (int flag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether same-frame optimizations are being used.  <a href="#a71f7fdf4416eef2225b275c30867f8a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_patch_pyramid.html#a35a3eb9f01dd6734eafabb080177724c">setObjectDetectorSource</a> (std::string newFileName)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the file used by the object detector for doing detecting. This is critical if a weights file is located at an absolute path that may have changed from training time.  <a href="#a35a3eb9f01dd6734eafabb080177724c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_patch_pyramid.html#a4f374af68c1d11242f1ba11be890f713">saveVisualization</a> (IplImage *grayFrame, CvPoint searchPoint, const char *base_filename)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a variety of visual representations of the process of fixating with an IPP to image files.  <a href="#a4f374af68c1d11242f1ba11be890f713"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">IplImage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_patch_pyramid.html#af7294b7d0787a653edd73687c018352d">objectCount</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of times the object-detector fired in each grid-cell suring the last call to <a class="el" href="class_image_patch_pyramid.html#aefdbf7e8d423fa3f3539c8be9abd6b3b" title="The main method for generating an observation vector: given an image, generate a count of object-dete...">searchFrameAtGridPoint()</a> or <a class="el" href="class_image_patch_pyramid.html#a0bd72e73795a97189e5ecd6348616a08" title="Apply the object detector to the entire image. This is used for comparing the speed and accuracy of t...">searchHighResImage()</a>.  <a href="#af7294b7d0787a653edd73687c018352d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">IplImage *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_patch_pyramid.html#a7bd5c96cc24c8d9aaa30f500d7e8aa10">foveaRepresentation</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A visually informative representation of the IPP Foveal represention.  <a href="#a7bd5c96cc24c8d9aaa30f500d7e8aa10"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_open_c_v_haar_detector.html">OpenCVHaarDetector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_patch_pyramid.html#ae2c4b6f81c5c567ae07e3167e9aaad6b">detector</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the oject detector used in searching. By exposing this variable, it is easy to switch out the object detector that is applied to an IPP, or to change its properties.  <a href="#ae2c4b6f81c5c567ae07e3167e9aaad6b"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66a4b4b6a9648b439632728ecc8c294d"></a><!-- doxytag: member="ImagePatchPyramid::operator&lt;&lt;" ref="a66a4b4b6a9648b439632728ecc8c294d" args="(std::ostream &amp;ofs, ImagePatchPyramid *a)" -->
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_patch_pyramid.html#a66a4b4b6a9648b439632728ecc8c294d">operator&lt;&lt;</a> (std::ostream &amp;ofs, <a class="el" href="class_image_patch_pyramid.html">ImagePatchPyramid</a> *a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to a file. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeef96d77a4b2a5c2f4d2d8042bd42816"></a><!-- doxytag: member="ImagePatchPyramid::operator&gt;&gt;" ref="aeef96d77a4b2a5c2f4d2d8042bd42816" args="(std::istream &amp;ifs, ImagePatchPyramid *a)" -->
std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_image_patch_pyramid.html#aeef96d77a4b2a5c2f4d2d8042bd42816">operator&gt;&gt;</a> (std::istream &amp;ifs, <a class="el" href="class_image_patch_pyramid.html">ImagePatchPyramid</a> *a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from a file. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><code>Auxilliary Tool:</code> The main data structure for the <a class="el" href="class_m_i_p_o_m_d_p.html" title="  Machine Perception Primitive:   An implementation of the &quot;Multinomial IPOMDP&quot; algorithm f...">MIPOMDP</a> algorithm. It is reponsible for generating the <a class="el" href="class_m_i_p_o_m_d_p.html" title="  Machine Perception Primitive:   An implementation of the &quot;Multinomial IPOMDP&quot; algorithm f...">MIPOMDP</a> observation vector. The <a class="el" href="class_image_patch_pyramid.html" title="Auxilliary Tool: The main data structure for the MIPOMDP algorithm. It is reponsible for generating t...">ImagePatchPyramid</a> (IPP) is described in detail in Butko &amp; Movellan 2009 (see <a class="el" href="bib_page.html#bib_sec">Related Publications</a>). </p>
<p>The IPP data structure divides an image up into grid-cells. It then extracts image patches comprising different numbers of grid-cells, and scales them down to a common size, and searches each patch for the target object. Any objects that are found in any grid-cell in any patch are added to a count-vector element corresponding to that grid-cell. This count-vector forms the bases for the <a class="el" href="class_m_i_p_o_m_d_p.html" title="  Machine Perception Primitive:   An implementation of the &quot;Multinomial IPOMDP&quot; algorithm f...">MIPOMDP</a> Observation.</p>
<p>In order to perform the above behavior, an IPP needs to know how big the images it receives are, to what smaller size it should scale each image patch, the size (height/width) of the grid-cell tiling of the image, how many image patches there will be, the size (height/width) in grid-cells of each image patch, and what object detector to apply.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>Nicholas Butko </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>2010 </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>0.4 </dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab412629f27d09a06b1acbbd736cbe711"></a><!-- doxytag: member="ImagePatchPyramid::ImagePatchPyramid" ref="ab412629f27d09a06b1acbbd736cbe711" args="(CvSize inputImageSize, CvSize subImageSize, CvSize gridSize, int numSubImages, CvMat *subImageGridPoints, OpenCVHaarDetector *detector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ImagePatchPyramid::ImagePatchPyramid </td>
          <td>(</td>
          <td class="paramtype">CvSize&#160;</td>
          <td class="paramname"> <em>inputImageSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CvSize&#160;</td>
          <td class="paramname"> <em>subImageSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CvSize&#160;</td>
          <td class="paramname"> <em>gridSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>numSubImages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CvMat *&#160;</td>
          <td class="paramname"> <em>subImageGridPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_open_c_v_haar_detector.html">OpenCVHaarDetector</a> *&#160;</td>
          <td class="paramname"> <em>detector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Main Constructor: Manually create an IPP. </p>
<p>An IPP needs to know how big the images it receives are, to what smaller size it should scale each image patch, the size (height/width) of the grid-cell tiling of the image, how many image patches there will be, the size (height/width) in grid-cells of each image patch, and what object detector to apply.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inputImageSize</td><td>The size of the images that will be given to the IPP to turn into <a class="el" href="class_m_i_p_o_m_d_p.html" title="  Machine Perception Primitive:   An implementation of the &quot;Multinomial IPOMDP&quot; algorithm f...">MIPOMDP</a> observations. This allocates memory for underlying data, but it can be changed easily later if needed without recreating the object by calling the changeInputSize() functions.</td></tr>
    <tr><td class="paramname">subImageSize</td><td>The common size to which all image patches will be reduced, creating the foveation effect. The smaller subImageSize is, the faster search is, and the more extreme the effect of foveation. This allocates memory for underlying data, but it can be changed easily later if needed without recreating the object by calling the changeInputSize() functions.</td></tr>
    <tr><td class="paramname">gridSize</td><td>Size of the discretization of the image. The number of POMDP states is the product of the demensions of this size (e.g. 21x21).</td></tr>
    <tr><td class="paramname">numSubImages</td><td>Number of Patches in the Image Patch Pyramid.</td></tr>
    <tr><td class="paramname">subImageGridPoints</td><td>A matrix that describes the size and shape of each level (patch) of the IP Pyramid. This must be a matrix with size [numSubImages x 2]. Each row contains the width and height of the corresponding levels. These should be in order of *decreasing* size, so that the largest Image Patch is first. For example, in Butko and Movellan CVPR 2009, we used [21 21; 15 15; 9 9; 3 3]. Finaly, note that it is not necessary that the largest patch cover the entire image. However, when the largest patch is the same size as grid-cell-matrix, special optimizations become available that reduce the complexity of the algorithm when the same image, or same frame of video, is fixated multiple times.</td></tr>
    <tr><td class="paramname">detector</td><td>A pointer to an object detector. This object detector will be applied to each patch in the IPP, forming the basis for the <a class="el" href="class_m_i_p_o_m_d_p.html" title="  Machine Perception Primitive:   An implementation of the &quot;Multinomial IPOMDP&quot; algorithm f...">MIPOMDP</a> observation model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7fe16df82917dd6fc6f059a11094a071"></a><!-- doxytag: member="ImagePatchPyramid::ImagePatchPyramid" ref="a7fe16df82917dd6fc6f059a11094a071" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ImagePatchPyramid::ImagePatchPyramid </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Placeholder Constructor. </p>
<p>Used to create a placeholder for an IPP, which can then be read from a file stream using the &gt;&gt; operator. Typical usage for this constructor is:</p>
<p><code> ipp = new <a class="el" href="class_image_patch_pyramid.html#a7fe16df82917dd6fc6f059a11094a071" title="Placeholder Constructor.">ImagePatchPyramid()</a>; <br/>
 in &gt;&gt; ipp; </code> </p>

</div>
</div>
<a class="anchor" id="a734ed81add18902c3723c1312354616d"></a><!-- doxytag: member="ImagePatchPyramid::~ImagePatchPyramid" ref="a734ed81add18902c3723c1312354616d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ImagePatchPyramid::~ImagePatchPyramid </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default Destructor. </p>
<p>Deallocates all memory associated with the IPP. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a1bf5feb8afc9764e2978e38b0709167f"></a><!-- doxytag: member="ImagePatchPyramid::changeInputImageSize" ref="a1bf5feb8afc9764e2978e38b0709167f" args="(CvSize newInputSize, CvSize newSubImageSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImagePatchPyramid::changeInputImageSize </td>
          <td>(</td>
          <td class="paramtype">CvSize&#160;</td>
          <td class="paramname"> <em>newInputSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CvSize&#160;</td>
          <td class="paramname"> <em>newSubImageSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the size of the input image and the downsampled image patches. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">newInputSize</td><td>The size of the next image that will be searched.</td></tr>
    <tr><td class="paramname">newSubImageSize</td><td>The desired size of the downsampled image patches. If the subImageSize is too small (below <a class="el" href="class_image_patch_pyramid.html#a89642bceb1e9d66e63614268ad414e61" title="Get the minimum allowed subImageSize.">getMinSize()</a>), the smallest scale is dropped and subImageSize is scaled up proportionally to the next scale. This process is repeated until subImageSIze is greater than <a class="el" href="class_image_patch_pyramid.html#a89642bceb1e9d66e63614268ad414e61" title="Get the minimum allowed subImageSize.">getMinSize()</a>. By default, minSize is 60x40. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae9811241e2b3519a51eb4eaadf174d27"></a><!-- doxytag: member="ImagePatchPyramid::changeInputImageSize" ref="ae9811241e2b3519a51eb4eaadf174d27" args="(CvSize newInputSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImagePatchPyramid::changeInputImageSize </td>
          <td>(</td>
          <td class="paramtype">CvSize&#160;</td>
          <td class="paramname"> <em>newInputSize</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the size of the input image and the downsampled image patches. Omitting a newSubImageSize causes the smallest-used-scale to have a 1-1 pixel mapping with the downsampled image patch -- i.e. information is not lost in the smallest scale. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">newInputSize</td><td>The size of the next image that will be searched. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a89642bceb1e9d66e63614268ad414e61"></a><!-- doxytag: member="ImagePatchPyramid::getMinSize" ref="a89642bceb1e9d66e63614268ad414e61" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CvSize ImagePatchPyramid::getMinSize </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the minimum allowed subImageSize. </p>
<p>If the subImageSize is too small (below <a class="el" href="class_image_patch_pyramid.html#a89642bceb1e9d66e63614268ad414e61" title="Get the minimum allowed subImageSize.">getMinSize()</a>), the smallest scale is dropped and subImageSize is scaled up proportionally to the next scale. This process is repeated until subImageSIze is greater than <a class="el" href="class_image_patch_pyramid.html#a89642bceb1e9d66e63614268ad414e61" title="Get the minimum allowed subImageSize.">getMinSize()</a>. By default, minSize is 60x40. </p>

</div>
</div>
<a class="anchor" id="a3cbefc440265f9ce34dee0ee9da9f57f"></a><!-- doxytag: member="ImagePatchPyramid::getNumScales" ref="a3cbefc440265f9ce34dee0ee9da9f57f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ImagePatchPyramid::getNumScales </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The total number of levels that the IP Pyramid has. </p>
<p>Note that this may be different from the number of scales that the IP Pyramid is *using*. If the subImageSize is too small (below <a class="el" href="class_image_patch_pyramid.html#a89642bceb1e9d66e63614268ad414e61" title="Get the minimum allowed subImageSize.">getMinSize()</a>), the smallest scale is dropped and subImageSize is scaled up proportionally to the next scale. This process is repeated until subImageSIze is greater than <a class="el" href="class_image_patch_pyramid.html#a89642bceb1e9d66e63614268ad414e61" title="Get the minimum allowed subImageSize.">getMinSize()</a>. To find out how many scales that the IPP is using, call <a class="el" href="class_image_patch_pyramid.html#a1cc5ed7899cd020716b4174ea9aec65f" title="The total number of levels that the IP Pyramid is currently using.">getUsedScales()</a>. </p>

</div>
</div>
<a class="anchor" id="ad6fcecf811160e9eba874ee1dc2067d6"></a><!-- doxytag: member="ImagePatchPyramid::getSameFrameOptimizations" ref="ad6fcecf811160e9eba874ee1dc2067d6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ImagePatchPyramid::getSameFrameOptimizations </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check whether same-frame optimizations are being used. </p>
<p>Under certain conditions, the computation needed to search a frame a second time are less than the computations needed to search it a first time. In these conditions, the same-frame optimizations will automatically be used. However, this requires setting <a class="el" href="class_image_patch_pyramid.html#a28f8eba799e27a05af28ef0ec150da91" title="Tell the IPP not to use the next-frame optimizations for the next frame.">setNewImage()</a> each time the image to search changes (i.e. a new frame). If you are in a situation in which you know that each frame will only be fixated at one point, you may wish to turn same-frame optimizations off. </p>

</div>
</div>
<a class="anchor" id="a72e9c15911a6a703f3e810d0d29f0324"></a><!-- doxytag: member="ImagePatchPyramid::getSubImageSize" ref="a72e9c15911a6a703f3e810d0d29f0324" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CvSize ImagePatchPyramid::getSubImageSize </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The common reference size that image patches are down-scaled to. </p>
<p>This is not necessarily the value set in the constructor, or in <a class="el" href="class_image_patch_pyramid.html#ae9811241e2b3519a51eb4eaadf174d27" title="Change the size of the input image and the downsampled image patches. Omitting a newSubImageSize caus...">changeInputImageSize()</a>. If the requested subImageSize is too small (below <a class="el" href="class_image_patch_pyramid.html#a89642bceb1e9d66e63614268ad414e61" title="Get the minimum allowed subImageSize.">getMinSize()</a>), the smallest scale is dropped and subImageSize is scaled up proportionally to the next scale. This process is repeated until subImageSIze is greater than <a class="el" href="class_image_patch_pyramid.html#a89642bceb1e9d66e63614268ad414e61" title="Get the minimum allowed subImageSize.">getMinSize()</a>. </p>

</div>
</div>
<a class="anchor" id="a1cc5ed7899cd020716b4174ea9aec65f"></a><!-- doxytag: member="ImagePatchPyramid::getUsedScales" ref="a1cc5ed7899cd020716b4174ea9aec65f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ImagePatchPyramid::getUsedScales </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The total number of levels that the IP Pyramid is currently using. </p>
<p>Note that this may be different from the number of scales that the IP Pyramid has. If the subImageSize is too small (below <a class="el" href="class_image_patch_pyramid.html#a89642bceb1e9d66e63614268ad414e61" title="Get the minimum allowed subImageSize.">getMinSize()</a>), the smallest scale is dropped and subImageSize is scaled up proportionally to the next scale. This process is repeated until subImageSIze is greater than <a class="el" href="class_image_patch_pyramid.html#a89642bceb1e9d66e63614268ad414e61" title="Get the minimum allowed subImageSize.">getMinSize()</a>. To find out how many scales that the IPP is has, call <a class="el" href="class_image_patch_pyramid.html#a3cbefc440265f9ce34dee0ee9da9f57f" title="The total number of levels that the IP Pyramid has.">getNumScales()</a>. </p>

</div>
</div>
<a class="anchor" id="a7fab3f9c5a286e6be1a3987ca5662f38"></a><!-- doxytag: member="ImagePatchPyramid::getVisibleRegion" ref="a7fab3f9c5a286e6be1a3987ca5662f38" args="(CvPoint searchPoint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CvRect ImagePatchPyramid::getVisibleRegion </td>
          <td>(</td>
          <td class="paramtype">CvPoint&#160;</td>
          <td class="paramname"> <em>searchPoint</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the region of the belief map that is visible in any scales when fixating a grid-point. </p>
<p>NOTE: We assume that all patches are concentric, and that the largest image patch comes first.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">searchPoint</td><td>The grid-cell center of fixation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4f374af68c1d11242f1ba11be890f713"></a><!-- doxytag: member="ImagePatchPyramid::saveVisualization" ref="a4f374af68c1d11242f1ba11be890f713" args="(IplImage *grayFrame, CvPoint searchPoint, const char *base_filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImagePatchPyramid::saveVisualization </td>
          <td>(</td>
          <td class="paramtype">IplImage *&#160;</td>
          <td class="paramname"> <em>grayFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CvPoint&#160;</td>
          <td class="paramname"> <em>searchPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> <em>base_filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a variety of visual representations of the process of fixating with an IPP to image files. </p>
<p>This method saves a series of .png image files, each with a prefix given by base_filename. Images with the following suffix are created: </p>
<ul>
<li>FullInputImage - The full input image contained in grayFrame. </li>
<li>Scale-[0:N] - The down-sampled representation of each image patch. </li>
<li>FoveatedInputImage - A reconstruction of the full image using the donwsampled patches. </li>
<li>FoveatedInputImageWithLooking - Same as above, with white boxes drawn around each scale. </li>
<li>FoveatedInputImageWithGrid - Same as above, but with a grid overlayed showing the grid-cells. </li>
<li>FullInputImageWithGrid - Full image with black rectangles showing grid-cell locations. </li>
<li>FullInputImageWithLooking - Same as above, but with wite boxes drawn around each scale.</li>
</ul>
<p>Additionally, one CSV file is created, suffix "FaceCounts.csv", which records the output of the object detector on the foveated representation in each grid-cell.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">grayFrame</td><td>The image to search. This image should have size inputImageSize, and be of type IPL_DEPTH_8U with a single channel.</td></tr>
    <tr><td class="paramname">searchPoint</td><td>The center of fixation.</td></tr>
    <tr><td class="paramname">base_filename</td><td>All of the files generated by this function will be given this as a prefix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aefdbf7e8d423fa3f3539c8be9abd6b3b"></a><!-- doxytag: member="ImagePatchPyramid::searchFrameAtGridPoint" ref="aefdbf7e8d423fa3f3539c8be9abd6b3b" args="(IplImage *grayFrame, CvPoint searchPoint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImagePatchPyramid::searchFrameAtGridPoint </td>
          <td>(</td>
          <td class="paramtype">IplImage *&#160;</td>
          <td class="paramname"> <em>grayFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CvPoint&#160;</td>
          <td class="paramname"> <em>searchPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The main method for generating an observation vector: given an image, generate a count of object-detector firings in each grid-cell based on a fixation point. After this method is called, the resulting observation is stored in the objectCount element. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">grayFrame</td><td>The image to search. This image should have size inputImageSize, and be of type IPL_DEPTH_8U with a single channel.</td></tr>
    <tr><td class="paramname">searchPoint</td><td>The grid-cell center of fixation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0bd72e73795a97189e5ecd6348616a08"></a><!-- doxytag: member="ImagePatchPyramid::searchHighResImage" ref="a0bd72e73795a97189e5ecd6348616a08" args="(IplImage *grayFrame)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CvPoint ImagePatchPyramid::searchHighResImage </td>
          <td>(</td>
          <td class="paramtype">IplImage *&#160;</td>
          <td class="paramname"> <em>grayFrame</em>&#160;)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply the object detector to the entire image. This is used for comparing the speed and accuracy of the foveated search strategy. After this method is called, the count of objects that the object detector found in each grid-cell in the high resolution image is stored in objectCount. The location of the object is inferred as being the grid-cell with the highest count. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">grayFrame</td><td>The image to search. This image should have size inputImageSize, and be of type IPL_DEPTH_8U with a single channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The grid-cell location with the highest count. </dd></dl>

</div>
</div>
<a class="anchor" id="aee6d5f72a851b2a0c7fb5882060fa1d4"></a><!-- doxytag: member="ImagePatchPyramid::setGeneratePreview" ref="aee6d5f72a851b2a0c7fb5882060fa1d4" args="(int flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImagePatchPyramid::setGeneratePreview </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>flag</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Turns on/off the code that modifies foveaRepresentation to visualize the process of fixating. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>Set to 0 if visualization is not desired (more efficient) or to 1 if visualization is desired. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af427daa054b3c7be5087f0aaf9ec5a2a"></a><!-- doxytag: member="ImagePatchPyramid::setMinSize" ref="af427daa054b3c7be5087f0aaf9ec5a2a" args="(CvSize minsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImagePatchPyramid::setMinSize </td>
          <td>(</td>
          <td class="paramtype">CvSize&#160;</td>
          <td class="paramname"> <em>minsize</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the minimum allowed subImageSize. </p>
<p>If the subImageSize is too small (below <a class="el" href="class_image_patch_pyramid.html#a89642bceb1e9d66e63614268ad414e61" title="Get the minimum allowed subImageSize.">getMinSize()</a>), the smallest scale is dropped and subImageSize is scaled up proportionally to the next scale. This process is repeated until subImageSIze is greater than <a class="el" href="class_image_patch_pyramid.html#a89642bceb1e9d66e63614268ad414e61" title="Get the minimum allowed subImageSize.">getMinSize()</a>. By default, minSize is 60x40.</p>
<p>The will have no effect on the current subImageSize, or <a class="el" href="class_image_patch_pyramid.html#a1cc5ed7899cd020716b4174ea9aec65f" title="The total number of levels that the IP Pyramid is currently using.">getUsedScales()</a> until <a class="el" href="class_image_patch_pyramid.html#ae9811241e2b3519a51eb4eaadf174d27" title="Change the size of the input image and the downsampled image patches. Omitting a newSubImageSize caus...">changeInputImageSize()</a> is called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">minsize</td><td>The minimum allowed subImageSize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a28f8eba799e27a05af28ef0ec150da91"></a><!-- doxytag: member="ImagePatchPyramid::setNewImage" ref="a28f8eba799e27a05af28ef0ec150da91" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImagePatchPyramid::setNewImage </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tell the IPP not to use the next-frame optimizations for the next frame. </p>
<p>Every time you are searching an image that is different from the one you searched before, this should be set (unless same-frame optimizations are turned off by the <a class="el" href="class_image_patch_pyramid.html#a71f7fdf4416eef2225b275c30867f8a3" title="Set whether same-frame optimizations are being used.">useSameFrameOptimizations()</a> function).</p>
<p>When interfacing with the IPP via the <a class="el" href="class_m_i_p_o_m_d_p.html" title="  Machine Perception Primitive:   An implementation of the &quot;Multinomial IPOMDP&quot; algorithm f...">MIPOMDP</a> class, <a class="el" href="class_image_patch_pyramid.html#a28f8eba799e27a05af28ef0ec150da91" title="Tell the IPP not to use the next-frame optimizations for the next frame.">setNewImage()</a> is always called for all search methods except <a class="el" href="class_image_patch_pyramid.html#aefdbf7e8d423fa3f3539c8be9abd6b3b" title="The main method for generating an observation vector: given an image, generate a count of object-dete...">searchFrameAtGridPoint()</a>. </p>

</div>
</div>
<a class="anchor" id="a35a3eb9f01dd6734eafabb080177724c"></a><!-- doxytag: member="ImagePatchPyramid::setObjectDetectorSource" ref="a35a3eb9f01dd6734eafabb080177724c" args="(std::string newFileName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImagePatchPyramid::setObjectDetectorSource </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"> <em>newFileName</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the file used by the object detector for doing detecting. This is critical if a weights file is located at an absolute path that may have changed from training time. </p>
<p>When an <a class="el" href="class_object_detector.html" title="Auxilliary Tool: A virtual class for providing the skeleton for specific object detectors.">ObjectDetector</a> is loaded from disk, it will try to reload its weights file from the same source used in training. If this fails, a warning will be printed, and the detector's source will need to be set. </p>

</div>
</div>
<a class="anchor" id="a71f7fdf4416eef2225b275c30867f8a3"></a><!-- doxytag: member="ImagePatchPyramid::useSameFrameOptimizations" ref="a71f7fdf4416eef2225b275c30867f8a3" args="(int flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImagePatchPyramid::useSameFrameOptimizations </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>flag</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set whether same-frame optimizations are being used. </p>
<p>Under certain conditions, the computation needed to search a frame a second time are less than the computations needed to search it a first time. In these conditions, the same-frame optimizations will automatically be used. However, this requires setting <a class="el" href="class_image_patch_pyramid.html#a28f8eba799e27a05af28ef0ec150da91" title="Tell the IPP not to use the next-frame optimizations for the next frame.">setNewImage()</a> each time the image to search changes (i.e. a new frame). If you are in a situation in which you know that each frame will only be fixated at one point, you may wish to turn same-frame optimizations off.</p>
<p>Generally same-frame optimizations should not be turned on unless you know that they were turned on automatically. Turning them on when inappropriate will lead to incorrect behavior. In general, it is appropriate to turn them on if the first scale (largest scale) in the IPP is the same size as entire visual field.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>If 0, Same Frame Optimizations will not be used. If 1, Same Frame Optimizations will be used regardless of whether or not it's appropriate. Be careful setting this to 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="ae2c4b6f81c5c567ae07e3167e9aaad6b"></a><!-- doxytag: member="ImagePatchPyramid::detector" ref="ae2c4b6f81c5c567ae07e3167e9aaad6b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_open_c_v_haar_detector.html">OpenCVHaarDetector</a>* <a class="el" href="class_image_patch_pyramid.html#ae2c4b6f81c5c567ae07e3167e9aaad6b">ImagePatchPyramid::detector</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A pointer to the oject detector used in searching. By exposing this variable, it is easy to switch out the object detector that is applied to an IPP, or to change its properties. </p>
<p>For example, with an <a class="el" href="class_open_c_v_haar_detector.html" title="Auxilliary Tool: A specific object detector that uses OpenCV&#39;s Haar Cascade Classifier to detect ...">OpenCVHaarDetector</a>, the search granularity and minimum-patch-size parameters can be changed. </p>

</div>
</div>
<a class="anchor" id="a7bd5c96cc24c8d9aaa30f500d7e8aa10"></a><!-- doxytag: member="ImagePatchPyramid::foveaRepresentation" ref="a7bd5c96cc24c8d9aaa30f500d7e8aa10" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IplImage* <a class="el" href="class_image_patch_pyramid.html#a7bd5c96cc24c8d9aaa30f500d7e8aa10">ImagePatchPyramid::foveaRepresentation</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A visually informative representation of the IPP Foveal represention. </p>
<p>This is meant as an image that is appropriate for display in a GUI, to visualize the algorithm in action. The image has the same size as inputImageSize. In order to increase efficiency, generation of this visualization should be disabled if it is not going to be accessed. This can be achieved by calling setGeneratePreview(0). </p>

</div>
</div>
<a class="anchor" id="af7294b7d0787a653edd73687c018352d"></a><!-- doxytag: member="ImagePatchPyramid::objectCount" ref="af7294b7d0787a653edd73687c018352d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IplImage* <a class="el" href="class_image_patch_pyramid.html#af7294b7d0787a653edd73687c018352d">ImagePatchPyramid::objectCount</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Number of times the object-detector fired in each grid-cell suring the last call to <a class="el" href="class_image_patch_pyramid.html#aefdbf7e8d423fa3f3539c8be9abd6b3b" title="The main method for generating an observation vector: given an image, generate a count of object-dete...">searchFrameAtGridPoint()</a> or <a class="el" href="class_image_patch_pyramid.html#a0bd72e73795a97189e5ecd6348616a08" title="Apply the object detector to the entire image. This is used for comparing the speed and accuracy of t...">searchHighResImage()</a>. </p>
<p>Has IplImage type IPL_DEPTH_8U, 1 channel. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/nick/projects/NickThesis/Code/OpenCV/src/ImagePatchPyramid.h</li>
<li>/Users/nick/projects/NickThesis/Code/OpenCV/src/ImagePatchPyramid.cpp</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Dec 9 2010 16:05:48 for Nick's Machine Perception Toolbox by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
