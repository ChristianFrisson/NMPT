<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Nick&#39;s Machine Perception Toolbox: OpenCV2BoxFilter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>OpenCV2BoxFilter Class Reference<br/>
<small>
[<a class="el" href="group___aux_group.html">Auxilliary Tools</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="OpenCV2BoxFilter" -->
<p><code>Auxilliary Tool:</code> A class for efficiently applying multiple box convolutions to the same image.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;OpenCV2BoxFilter.h&gt;</code></p>

<p><a href="class_open_c_v2_box_filter-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v2_box_filter.html#a9bd96738a7e57992637b0717e605c5f7">OpenCV2BoxFilter</a> (int maxPaddingRequired, int filteType=CV_32F)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a9bd96738a7e57992637b0717e605c5f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v2_box_filter.html#a80ac6444db6b31eda22798a556ed877b">OpenCV2BoxFilter</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a80ac6444db6b31eda22798a556ed877b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af04f23e503a4465171f3db86c12e7405"></a><!-- doxytag: member="OpenCV2BoxFilter::OpenCV2BoxFilter" ref="af04f23e503a4465171f3db86c12e7405" args="(const OpenCV2BoxFilter &amp;rhs)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v2_box_filter.html#af04f23e503a4465171f3db86c12e7405">OpenCV2BoxFilter</a> (const <a class="el" href="class_open_c_v2_box_filter.html">OpenCV2BoxFilter</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy Constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a741c986b1950928ac494745503173f55"></a><!-- doxytag: member="OpenCV2BoxFilter::operator=" ref="a741c986b1950928ac494745503173f55" args="(const OpenCV2BoxFilter &amp;rhs)" -->
<a class="el" href="class_open_c_v2_box_filter.html">OpenCV2BoxFilter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v2_box_filter.html#a741c986b1950928ac494745503173f55">operator=</a> (const <a class="el" href="class_open_c_v2_box_filter.html">OpenCV2BoxFilter</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment Operator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v2_box_filter.html#aeab7b9f6d4d8b886f8c4aacaed322fc2">~OpenCV2BoxFilter</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Destructor.  <a href="#aeab7b9f6d4d8b886f8c4aacaed322fc2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v2_box_filter.html#a4a20bcc5a2ff739d22016a26a2e1cb2b">setNewImage</a> (const cv::Mat &amp;imageToFilter)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the image that will be filtered. The source image is assumed to be single channel image, of a type supported by cv::integral.  <a href="#a4a20bcc5a2ff739d22016a26a2e1cb2b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v2_box_filter.html#aee9609a7fca60f627e76788b5362cd76">setBoxFilter</a> (cv::Mat &amp;destinationImage, cv::Rect boxPosition=cv::Rect(0, 0, 1, 1), double scaleResultFactor=1.0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a box filter and over-write the result to an image. The result of filtering is the sum of the pixel values in the specified rectangular region. It will be a 64-bit single channel floating point image.  <a href="#aee9609a7fca60f627e76788b5362cd76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v2_box_filter.html#a9354d9b95c8e0afffe583dce5706f910">accumulateBoxFilter</a> (cv::Mat &amp;destinationImage, cv::Rect boxPosition=cv::Rect(0, 0, 1, 1), double scaleResultFactor=1.0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a box filter and add the result to an image. The result of filtering is the average of the pixel values in the specified rectangular region. This is useful for designing filters composed of multiple boxes.  <a href="#a9354d9b95c8e0afffe583dce5706f910"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><code>Auxilliary Tool:</code> A class for efficiently applying multiple box convolutions to the same image. </p>
<p>By computing the integral image once, an image can be filtered multiple times with boxes of different sizes. Requires OpenCV libraries.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>Nicholas Butko </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>2010 version 0.4 </dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9bd96738a7e57992637b0717e605c5f7"></a><!-- doxytag: member="OpenCV2BoxFilter::OpenCV2BoxFilter" ref="a9bd96738a7e57992637b0717e605c5f7" args="(int maxPaddingRequired, int filteType=CV_32F)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCV2BoxFilter::OpenCV2BoxFilter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>maxPaddingRequired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>filteType</em> = <code>CV_32F</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<p>NOTE: The source image is assumed to be single channel image, of a type supported by cv::Integral. The destination image will be a 64-bit floating point image.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">maxPaddingRequired</td><td>Extra memory required for performing convolutions. In practice, this must be the distance from the central pixel of the most extreme point of any box we expect to use, i.e. at least the maximum intended value of: (1) |boxPosition.x|, (2) |boxPosition.x+boxPosition.width-1|, (3) |boxPosition.y|, (4) |boxPosition.y+boxPosition.height-1|. Erring on the side of too much padding has no adverse consequences other than increased memory usage.</td></tr>
    <tr><td class="paramname">filterType</td><td>OpenCV data type for output of filtering. Can be CV_32S, CV_32F, CV_64F. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a80ac6444db6b31eda22798a556ed877b"></a><!-- doxytag: member="OpenCV2BoxFilter::OpenCV2BoxFilter" ref="a80ac6444db6b31eda22798a556ed877b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCV2BoxFilter::OpenCV2BoxFilter </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<p>NOTE: The source image is assumed to be single channel image, of a type supported by cv::Integral. The destination image will be a 64-bit floating point image.</p>
<p>NOTE: call setMaxPaddingRequired later. </p>

</div>
</div>
<a class="anchor" id="aeab7b9f6d4d8b886f8c4aacaed322fc2"></a><!-- doxytag: member="OpenCV2BoxFilter::~OpenCV2BoxFilter" ref="aeab7b9f6d4d8b886f8c4aacaed322fc2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCV2BoxFilter::~OpenCV2BoxFilter </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default Destructor. </p>
<p>Deallocates all memory associated with the box filter. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a9354d9b95c8e0afffe583dce5706f910"></a><!-- doxytag: member="OpenCV2BoxFilter::accumulateBoxFilter" ref="a9354d9b95c8e0afffe583dce5706f910" args="(cv::Mat &amp;destinationImage, cv::Rect boxPosition=cv::Rect(0, 0, 1, 1), double scaleResultFactor=1.0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCV2BoxFilter::accumulateBoxFilter </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>destinationImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Rect&#160;</td>
          <td class="paramname"> <em>boxPosition</em> = <code>cv::Rect(0,&#160;0,&#160;1,&#160;1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>scaleResultFactor</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute a box filter and add the result to an image. The result of filtering is the average of the pixel values in the specified rectangular region. This is useful for designing filters composed of multiple boxes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">destinationImage</td><td>Image target for the results of the filtering. After invoking this method, the contents of this variable will be overwritten with the results of the operation. </td></tr>
    <tr><td class="paramname">boxPosition</td><td>Location of the box (relative to the central pixel) to average pixel values over. For example, cvRect(0,0,1,1) has zero-offset from the current pixel and a width/height of one pixel. Filtering the image in this way will return the original image. To filter with a width-5 averaging filter with no offset, use cvRect(-2,-2,5,5). </td></tr>
    <tr><td class="paramname">scaleResultFactor</td><td>Scale the result by some factor. For example, if the scale is boxPosition.width*boxPosition.height, the sum of the pixels in the box is returned instead of the average. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aee9609a7fca60f627e76788b5362cd76"></a><!-- doxytag: member="OpenCV2BoxFilter::setBoxFilter" ref="aee9609a7fca60f627e76788b5362cd76" args="(cv::Mat &amp;destinationImage, cv::Rect boxPosition=cv::Rect(0, 0, 1, 1), double scaleResultFactor=1.0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCV2BoxFilter::setBoxFilter </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>destinationImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Rect&#160;</td>
          <td class="paramname"> <em>boxPosition</em> = <code>cv::Rect(0,&#160;0,&#160;1,&#160;1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>scaleResultFactor</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute a box filter and over-write the result to an image. The result of filtering is the sum of the pixel values in the specified rectangular region. It will be a 64-bit single channel floating point image. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">destinationImage</td><td>Image target for the results of the filtering. After invoking this method, the contents of this variable will be overwritten with the results of the operation. </td></tr>
    <tr><td class="paramname">boxPosition</td><td>Location of the box (relative to the central pixel) to average pixel values over. For example, cvRect(0,0,1,1) has zero-offset from the current pixel and a width/height of one pixel. Filtering the image in this way will return the original image. To filter with a width-5 averaging filter with no offset, use cvRect(-2,-2,5,5). </td></tr>
    <tr><td class="paramname">scaleResultFactor</td><td>Scale the result by some factor. For example, if the scale is 1/boxPosition.width*boxPosition.height, the average of the pixels in the box is returned instead of the sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4a20bcc5a2ff739d22016a26a2e1cb2b"></a><!-- doxytag: member="OpenCV2BoxFilter::setNewImage" ref="a4a20bcc5a2ff739d22016a26a2e1cb2b" args="(const cv::Mat &amp;imageToFilter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCV2BoxFilter::setNewImage </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>imageToFilter</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the image that will be filtered. The source image is assumed to be single channel image, of a type supported by cv::integral. </p>
<p>This method computes a new integral image that will be used repeatedly for future filtering, until this method is invoked again with a new image. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">imageToFilter</td><td>A new OpenCV image to filter repeatedly. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/nick/projects/NickThesis/Code/OpenCV/src/OpenCV2BoxFilter.h</li>
<li>/Users/nick/projects/NickThesis/Code/OpenCV/src/OpenCV2BoxFilter.cpp</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Dec 9 2010 16:05:49 for Nick's Machine Perception Toolbox by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
