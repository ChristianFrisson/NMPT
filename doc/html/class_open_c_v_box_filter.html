<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Nick&#39;s Machine Perception Toolbox: OpenCVBoxFilter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>OpenCVBoxFilter Class Reference<br/>
<small>
[<a class="el" href="group___aux_group.html">Auxilliary Tools</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="OpenCVBoxFilter" -->
<p><code>Auxilliary Tool:</code> A class for efficiently applying multiple box convolutions to the same image.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;OpenCVBoxFilter.h&gt;</code></p>

<p><a href="class_open_c_v_box_filter-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_box_filter.html#a982324fd9306fea7d5e03feafcd90cc7">OpenCVBoxFilter</a> (int imageWidth, int imageHeight, int maxPaddingRequired)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a982324fd9306fea7d5e03feafcd90cc7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_box_filter.html#a0a13a7fbbd34d4419717246ee20e7e33">~OpenCVBoxFilter</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Destructor.  <a href="#a0a13a7fbbd34d4419717246ee20e7e33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_box_filter.html#abf20a421bbcbc549accd9e0bdb8733ee">setNewImage</a> (IplImage *imageToFilter)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the image that will be filtered.This must be a 32-bit single channel floating point image.  <a href="#abf20a421bbcbc549accd9e0bdb8733ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_box_filter.html#aa5e41a84c29ed395cf7558b7d8668c35">setBoxFilter</a> (IplImage *destinationImage, CvRect boxPosition=cvRect(0, 0, 1, 1), double scaleResultFactor=1.0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a box filter and over-write the result to an image. The result of filtering is the sum of the pixel values in the specified rectangular region. This must be a 64-bit single channel floating point image.  <a href="#aa5e41a84c29ed395cf7558b7d8668c35"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_open_c_v_box_filter.html#a4d897bc5e53dd16d64b6188d02f348ff">accumulateBoxFilter</a> (IplImage *destinationImage, CvRect boxPosition=cvRect(0, 0, 1, 1), double scaleResultFactor=1.0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a box filter and add the result to an image. The result of filtering is the average of the pixel values in the specified rectangular region. This is useful for designing filters composed of multiple boxes.  <a href="#a4d897bc5e53dd16d64b6188d02f348ff"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><code>Auxilliary Tool:</code> A class for efficiently applying multiple box convolutions to the same image. </p>
<p>By computing the integral image once, an image can be filtered multiple times with boxes of different sizes. Requires OpenCV libraries.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>Nicholas Butko </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>2010 version 0.4 </dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a982324fd9306fea7d5e03feafcd90cc7"></a><!-- doxytag: member="OpenCVBoxFilter::OpenCVBoxFilter" ref="a982324fd9306fea7d5e03feafcd90cc7" args="(int imageWidth, int imageHeight, int maxPaddingRequired)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCVBoxFilter::OpenCVBoxFilter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>imageWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>imageHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>maxPaddingRequired</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<p>NOTE: The source image is assumed to be single channel, floating point, 32-bit. The destination image is assumed to be a single channel, floating point, 64-bit image.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">imageWidth</td><td>The width of the image that will be filtered. </td></tr>
    <tr><td class="paramname">imageHeight</td><td>The height of the image that will be filtered. </td></tr>
    <tr><td class="paramname">maxPaddingRequired</td><td>Extra memory required for performing convolutions. In practice, this must be the distance from the central pixel of the most extreme point of any box we expect to use, i.e. at least the maximum intended value of: (1) |boxPosition.x|, (2) |boxPosition.x+boxPosition.width-1|, (3) |boxPosition.y|, (4) |boxPosition.y+boxPosition.height-1|. Erring on the side of too much padding has no adverse consequences other than increased memory usage. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0a13a7fbbd34d4419717246ee20e7e33"></a><!-- doxytag: member="OpenCVBoxFilter::~OpenCVBoxFilter" ref="a0a13a7fbbd34d4419717246ee20e7e33" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCVBoxFilter::~OpenCVBoxFilter </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default Destructor. </p>
<p>Deallocates all memory associated with the box filter. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a4d897bc5e53dd16d64b6188d02f348ff"></a><!-- doxytag: member="OpenCVBoxFilter::accumulateBoxFilter" ref="a4d897bc5e53dd16d64b6188d02f348ff" args="(IplImage *destinationImage, CvRect boxPosition=cvRect(0, 0, 1, 1), double scaleResultFactor=1.0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCVBoxFilter::accumulateBoxFilter </td>
          <td>(</td>
          <td class="paramtype">IplImage *&#160;</td>
          <td class="paramname"> <em>destinationImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CvRect&#160;</td>
          <td class="paramname"> <em>boxPosition</em> = <code>cvRect(0,0,1,1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>scaleResultFactor</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute a box filter and add the result to an image. The result of filtering is the average of the pixel values in the specified rectangular region. This is useful for designing filters composed of multiple boxes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">destinationImage</td><td>Image target for the results of the filtering. After invoking this method, the contents of this variable will be overwritten with the results of the operation. </td></tr>
    <tr><td class="paramname">boxPosition</td><td>Location of the box (relative to the central pixel) to average pixel values over. For example, cvRect(0,0,1,1) has zero-offset from the current pixel and a width/height of one pixel. Filtering the image in this way will return the original image. To filter with a width-5 averaging filter with no offset, use cvRect(-2,-2,5,5). </td></tr>
    <tr><td class="paramname">scaleResultFactor</td><td>Scale the result by some factor. For example, if the scale is boxPosition.width*boxPosition.height, the sum of the pixels in the box is returned instead of the average. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa5e41a84c29ed395cf7558b7d8668c35"></a><!-- doxytag: member="OpenCVBoxFilter::setBoxFilter" ref="aa5e41a84c29ed395cf7558b7d8668c35" args="(IplImage *destinationImage, CvRect boxPosition=cvRect(0, 0, 1, 1), double scaleResultFactor=1.0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCVBoxFilter::setBoxFilter </td>
          <td>(</td>
          <td class="paramtype">IplImage *&#160;</td>
          <td class="paramname"> <em>destinationImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CvRect&#160;</td>
          <td class="paramname"> <em>boxPosition</em> = <code>cvRect(0,0,1,1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>scaleResultFactor</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute a box filter and over-write the result to an image. The result of filtering is the sum of the pixel values in the specified rectangular region. This must be a 64-bit single channel floating point image. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">destinationImage</td><td>Image target for the results of the filtering. After invoking this method, the contents of this variable will be overwritten with the results of the operation. </td></tr>
    <tr><td class="paramname">boxPosition</td><td>Location of the box (relative to the central pixel) to average pixel values over. For example, cvRect(0,0,1,1) has zero-offset from the current pixel and a width/height of one pixel. Filtering the image in this way will return the original image. To filter with a width-5 averaging filter with no offset, use cvRect(-2,-2,5,5). </td></tr>
    <tr><td class="paramname">scaleResultFactor</td><td>Scale the result by some factor. For example, if the scale is 1/boxPosition.width*boxPosition.height, the average of the pixels in the box is returned instead of the sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf20a421bbcbc549accd9e0bdb8733ee"></a><!-- doxytag: member="OpenCVBoxFilter::setNewImage" ref="abf20a421bbcbc549accd9e0bdb8733ee" args="(IplImage *imageToFilter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCVBoxFilter::setNewImage </td>
          <td>(</td>
          <td class="paramtype">IplImage *&#160;</td>
          <td class="paramname"> <em>imageToFilter</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change the image that will be filtered.This must be a 32-bit single channel floating point image. </p>
<p>This method computes a new integral image that will be used repeatedly for future filtering, until this method is invoked again with a new image. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">imageToFilter</td><td>A new OpenCV image to filter repeatedly. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/nick/projects/NickThesis/Code/OpenCV/src/OpenCVBoxFilter.h</li>
<li>/Users/nick/projects/NickThesis/Code/OpenCV/src/OpenCVBoxFilter.cpp</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Dec 9 2010 16:05:49 for Nick's Machine Perception Toolbox by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
