<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Nick&#39;s Machine Perception Toolbox: PatchList2 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a>  </div>
  <div class="headertitle">
<h1>PatchList2 Class Reference<br/>
<small>
[<a class="el" href="group___aux_group.html">Auxilliary Tools</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="PatchList2" -->
<p><code>Auxilliary Tool:</code> A class that does the necessary book keeping for filtering an image quickly at many scales.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;PatchList2.h&gt;</code></p>
<!-- startSectionHeader --><div class="dynheader">
Inheritance diagram for PatchList2:<!-- endSectionHeader --></div>
<!-- startSectionSummary --><!-- endSectionSummary --><!-- startSectionContent --><div class="dyncontent">
<div class="center"><img src="class_patch_list2__inherit__graph.png" border="0" usemap="#_patch_list2_inherit__map" alt="Inheritance graph"/></div>
<map name="_patch_list2_inherit__map" id="_patch_list2_inherit__map">
<area shape="rect" id="node3" href="class_fast_patch_list2.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ..." alt="" coords="5,83,120,112"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center><!-- endSectionContent --></div>

<p><a href="class_patch_list2-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_patch_list2.html#affde308529d9daafc0a50b8f3dc59c8e">PatchList2</a> (cv::Size basePatchSize, cv::Size minSize=cv::Size(0, 0), cv::Size maxSize=cv::Size(0, 0), double scaleInc=1.2, double stepWidth=1, int dontCopyImage=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#affde308529d9daafc0a50b8f3dc59c8e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8358bc768a964179b2fd8685d200f9e"></a><!-- doxytag: member="PatchList2::PatchList2" ref="ab8358bc768a964179b2fd8685d200f9e" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_patch_list2.html#ab8358bc768a964179b2fd8685d200f9e">PatchList2</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d6926e5ba3308b6efebf8788647a0bb"></a><!-- doxytag: member="PatchList2::PatchList2" ref="a6d6926e5ba3308b6efebf8788647a0bb" args="(const PatchList2 &amp;copy)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_patch_list2.html#a6d6926e5ba3308b6efebf8788647a0bb">PatchList2</a> (const <a class="el" href="class_patch_list2.html">PatchList2</a> &amp;copy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy Constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a4e1f30d9738a0ece9238ac61facda2"></a><!-- doxytag: member="PatchList2::operator=" ref="a4a4e1f30d9738a0ece9238ac61facda2" args="(const PatchList2 &amp;rhs)" -->
<a class="el" href="class_patch_list2.html">PatchList2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_patch_list2.html#a4a4e1f30d9738a0ece9238ac61facda2">operator=</a> (const <a class="el" href="class_patch_list2.html">PatchList2</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa67f39504775762976c07286ca615fa1"></a><!-- doxytag: member="PatchList2::~PatchList2" ref="aa67f39504775762976c07286ca615fa1" args="()" -->
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_patch_list2.html#aa67f39504775762976c07286ca615fa1">~PatchList2</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cv::Size&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_patch_list2.html#a7a502656f227cbe29052c2705de1574e">getBasePatchSize</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the base patch size, which is size of the object detector that you plan to apply. It is also the default search minSize, and other scale sizes are computed relative to it.  <a href="#a7a502656f227cbe29052c2705de1574e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_patch_list2.html#ac311401e00c9b92b78f16decde313fcf">setBasePatchSize</a> (cv::Size baseSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the base patch size, which is size of the object detector that you plan to apply. It is also the default search minSize, and other scale sizes are computed relative to it.  <a href="#ac311401e00c9b92b78f16decde313fcf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_patch_list2.html#a032c2487a9ec9c0ad752ded7ef548346">setImage</a> (const cv::Mat &amp;newImage)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the image to filter or process for object detection.  <a href="#a032c2487a9ec9c0ad752ded7ef548346"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_patch_list2.html#a40238c55e4ca38a85cf8f20b81edd73c">resetListToScale</a> (int scale)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare the data structure to search for objects at a certain scale.  <a href="#a40238c55e4ca38a85cf8f20b81edd73c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_patch_list2.html#a7888f0b3980380fc8cffdb1f6de78916">accumulateAndRemovePatchesBelowThreshold</a> (double threshold)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the values in destInds to an accumulator. Any accumulator values that are below threshold are removed from the list.  <a href="#a7888f0b3980380fc8cffdb1f6de78916"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_patch_list2.html#a0b91aa6a987b6820221f1a8002804b7d">keepOnlyLocalMaxima</a> (int radius)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove image patch candidates that have a nearby patch (within radius horizontal or vertical pixels) with a higher value.  <a href="#a0b91aa6a987b6820221f1a8002804b7d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_patch_list2.html#a1489591c934b623b9468a88f60888e9f">getRemainingPatches</a> (std::vector&lt; <a class="el" href="struct_search_result.html">SearchResult</a> &gt; &amp;searchResults) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get info about the patches that have not yet been removed from the <a class="el" href="class_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">PatchList</a> since calling <a class="el" href="class_patch_list2.html#a40238c55e4ca38a85cf8f20b81edd73c" title="Prepare the data structure to search for objects at a certain scale.">resetListToScale()</a>. Each <a class="el" href="struct_search_result.html" title="Auxilliary Tool: A data structure that keeps track of where objects were detected in the image...">SearchResult</a> contains info about the location of the patch in the original image, and its current accumulator value.  <a href="#a1489591c934b623b9468a88f60888e9f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6a5a0522488075b549ecd94587fbce0"></a><!-- doxytag: member="PatchList2::getProbImage" ref="ac6a5a0522488075b549ecd94587fbce0" args="(cv::Mat &amp;dest, double faceAreaPrior=.5, double faceInvisibleProb=.1) const " -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_patch_list2.html#ac6a5a0522488075b549ecd94587fbce0">getProbImage</a> (cv::Mat &amp;dest, double faceAreaPrior=.5, double faceInvisibleProb=.1) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a pixel-by-pixel estimate for this scale that there is an object located at that pixel. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cv::Size&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_patch_list2.html#a4fdf620fc4d60224e2cc676a1d908b63">getPatchSizeAtScale</a> (int scale=-1) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the effective object size if searching at a given (or the current) scale.  <a href="#a4fdf620fc4d60224e2cc676a1d908b63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cv::Size&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_patch_list2.html#a4d3f13d2b634c3603043364e87635c8d">getFilterSizeAtScale</a> (int scale=-1) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the filter size that should be applied at this scale. For <a class="el" href="class_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">PatchList</a>, this is always <a class="el" href="class_patch_list2.html#a7a502656f227cbe29052c2705de1574e" title="Get the base patch size, which is size of the object detector that you plan to apply. It is also the default search minSize, and other scale sizes are computed relative to it.">getBasePatchSize()</a>. In <a class="el" href="class_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">PatchList</a>, this always returns <a class="el" href="class_patch_list2.html#a7a502656f227cbe29052c2705de1574e" title="Get the base patch size, which is size of the object detector that you plan to apply. It is also the default search minSize, and other scale sizes are computed relative to it.">getBasePatchSize()</a>. In <a class="el" href="class_fast_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">FastPatchList</a>, this always returns getPatchSizeAtScale(scale).  <a href="#a4d3f13d2b634c3603043364e87635c8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cv::Size&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_patch_list2.html#ae972e27f5ffed5e447470625a82c88d9">getImageSizeAtScale</a> (int scale=-1) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the valid convolution image, for viewing filtering and accumulator results.  <a href="#ae972e27f5ffed5e447470625a82c88d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_patch_list2.html#a1ad023ddef8d01d4efc450261abad069">getIntegralWidthStepAtScale</a> (int scale=-1) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the width step of the integral image, i.e. how many integral_type elements are there in srcInds[i][j] before a pixel that is directly below [j].  <a href="#a1ad023ddef8d01d4efc450261abad069"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_patch_list2.html#a45898f4587da221047b6db2f23571e6f">getCurrentListLength</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of remaining patches at this scale. Initially, this has all patches in the scale, but may be reduced by repeated calls to <a class="el" href="class_patch_list2.html#a7888f0b3980380fc8cffdb1f6de78916" title="Adds the values in destInds to an accumulator. Any accumulator values that are below threshold are re...">accumulateAndRemovePatchesBelowThreshold()</a>.  <a href="#a45898f4587da221047b6db2f23571e6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_patch_list2.html#a6436afeb46c61dabc1ea52dd50533a18">getTotalPatches</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of patches available to this <a class="el" href="class_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">PatchList</a> at all scales.  <a href="#a6436afeb46c61dabc1ea52dd50533a18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_patch_list2.html#a116c3db117381ff18d499d62e278c13a">getNumScales</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of scales.  <a href="#a116c3db117381ff18d499d62e278c13a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_image_patch2.html">ImagePatch2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_patch_list2.html#aa862bbd326e5c266f19160a6473e1720">getNearbyPatches</a> (cv::Rect roi, int spatialRadius=0, int scaleRadius=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get patches near a region of interest. This is useful for augmenting the number of positive examples in a dataset by grabbing nearby patches, or for finding the image patch that is closest to a labelled location.  <a href="#aa862bbd326e5c266f19160a6473e1720"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_patch_list2.html#a4143de78cdcd7289fc0e9011934dbc34">fillImageWithPixelsOfSearchPatch</a> (cv::Mat &amp;dest, const <a class="el" href="struct_search_result.html">SearchResult</a> &amp;r) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the exact same pixels from the image patch that the filtering process sees. This is useful for pulling out hard background patches for training.  <a href="#a4143de78cdcd7289fc0e9011934dbc34"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_patch_list2.html#a1ef4a7f176e16bf65a33ad2643422ef4">setDontCopyImageData</a> (int flag=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Improve efficiency by only copying integral data (not image data). This makes fillImageWithPixelsOfSearchPatch fail.  <a href="#a1ef4a7f176e16bf65a33ad2643422ef4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_patch_list2.html#a59f7444d0242fa888c67a837883a21fd">setDontScaleDownPatches</a> (int flag=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Improve detail of patches when getting pixels of patch -- at the cost of extra memory. Only affects <a class="el" href="class_fast_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">FastPatchList</a>.  <a href="#a59f7444d0242fa888c67a837883a21fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_patch_list2.html#ae25cd74434086f3e1282299b096e0ec5">getFilterImage</a> (cv::Mat &amp;image) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output of image filtering process as an image which can be visualized.  <a href="#ae25cd74434086f3e1282299b096e0ec5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_patch_list2.html#ab0d7994f5800157b60ca6a6501219ac9">getAccumImage</a> (cv::Mat &amp;image) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output of filtering accumulation process as an image which can be visualized.  <a href="#ab0d7994f5800157b60ca6a6501219ac9"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66f764643757b081ff6cf00a8772431b"></a><!-- doxytag: member="PatchList2::srcInds" ref="a66f764643757b081ff6cf00a8772431b" args="" -->
std::vector&lt; const int * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_patch_list2.html#a66f764643757b081ff6cf00a8772431b">srcInds</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of pointers to the top-left of image patches still considered as candidate locations of the object. This pointer is exposed to allow <a class="el" href="class_box_feature.html" title="Auxilliary Tool: A linear feature that uses the &quot;Integral  Image&quot; trick to efficiently eval...">BoxFeature</a> to evaluate the image with maximal efficiency. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; double * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_patch_list2.html#acf1985dcd452f910a28c641ebe00ff63">destInds</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of pointers to corresponding to the filtering outputs of the remaining candidate patches in srcInds.  <a href="#acf1985dcd452f910a28c641ebe00ff63"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><code>Auxilliary Tool:</code> A class that does the necessary book keeping for filtering an image quickly at many scales. </p>
<p>Specifically, a <a class="el" href="class_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">PatchList</a> gives <a class="el" href="class_box_feature.html" title="Auxilliary Tool: A linear feature that uses the &quot;Integral  Image&quot; trick to efficiently eval...">BoxFeature</a>, <a class="el" href="class_feature_regressor.html" title="Auxilliary Tool: A data structure that learns a non-linear tuning curve for mapping feature outputs t...">FeatureRegressor</a>, and <a class="el" href="class_gentle_boost_cascaded_classifier.html" title="  Machine Perception Primitive:   An implementation of a GentleBoost cascaded classifier for full ima...">GentleBoostCascadedClassifier</a> a way to apply a single weak learner to all remaining candidate object image patches. GentleBoost requires that each weak learner output be accumulated with the output of other weak learners. <a class="el" href="class_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">PatchList</a> maintains this accumulator.</p>
<p>They key parameters controlling a <a class="el" href="class_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">PatchList</a> are the size of the image (using setImage), the base patch size, and the scale increment factor. Here as an example with an image of size 320x240, a base patch size of 30, and a scale increment of 1.2.</p>
<p>At scale 0, the image is simply copied, and an integral image is computed. It can be filtered in a region up to 29 pixels from the border by a filter of size 30x30 (which is the base patch size). ImageSize represents the size of this valid filtering region, which is 291x211 pixels and is useful for displaying an image representation of the fitlering output. Each of these pixels contains the output of the filtering of one patch, so there are 61401 patches at scale 0.</p>
<p>At scale 1, the size of patches to search increases by a factor of 1.2, giving a patchWidth of 36. Internally, the image is downscaled by a factor of 1.2, giving a 266x200 image, with a 237x171 valid filtering region, and 40527 total patches.</p>
<p>At scale 12, the patch size would be 30*(1.2^12)=267x267. This is larger than the height of the image, and so the largest scale is 11. Since the scales start at 0, there are 12 total scales:</p>
<p>The <a class="el" href="class_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">PatchList</a> has 12 scales containing 170925 total patches. </p>
<ul>
<li>Scale 0: PatchSize - 30x30; FilterSize - 30x30; ImageSize - 291x211; Patches - 61401 </li>
<li>Scale 1: PatchSize - 36x36; FilterSize - 30x30; ImageSize - 237x171; Patches - 40527 </li>
<li>Scale 2: PatchSize - 43x43; FilterSize - 30x30; ImageSize - 193x137; Patches - 26441 </li>
<li>Scale 3: PatchSize - 51x51; FilterSize - 30x30; ImageSize - 156x109; Patches - 17004 </li>
<li>Scale 4: PatchSize - 62x62; FilterSize - 30x30; ImageSize - 125x86; Patches - 10750 </li>
<li>Scale 5: PatchSize - 74x74; FilterSize - 30x30; ImageSize - 99x67; Patches - 6633 </li>
<li>Scale 6: PatchSize - 89x89; FilterSize - 30x30; ImageSize - 78x51; Patches - 3978 </li>
<li>Scale 7: PatchSize - 107x107; FilterSize - 30x30; ImageSize - 60x37; Patches - 2220 </li>
<li>Scale 8: PatchSize - 128x128; FilterSize - 30x30; ImageSize - 45x26; Patches - 1170 </li>
<li>Scale 9: PatchSize - 154x154; FilterSize - 30x30; ImageSize - 33x17; Patches - 561 </li>
<li>Scale 10: PatchSize - 185x185; FilterSize - 30x30; ImageSize - 22x9; Patches - 198 </li>
<li>Scale 11: PatchSize - 222x222; FilterSize - 30x30; ImageSize - 14x3; Patches - 42</li>
</ul>
<p>Other parameters that can be set are maxSize, minSize, and stepWidth. MaxSize changes the maximum searched patch size. If (0,0), then the smaller image dimension is used. MinSize changes the minimum searched patch size. If (0,0), the base patch size is used. Otherwise, the image is scaled in size by a factor of basePatchSize/minSize before searching. StepWidth reduces the number of patches searched by skipping rows and columns. If StepWidth is 1, each patch location is searched. If it is 2, every other one is searched. If it is 2/3, then two consecutive patches are searched and one is skipped.</p>
<p><a class="el" href="class_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">PatchList</a> is effecicient about not doing more memory allocation than it needs. A rule of thumb is that giving a <a class="el" href="class_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">PatchList</a> images of different sizes will incur a slowdown, but if all images are the same size, then subsequent calls to setImage will be faster.</p>
<p>For example, a typical time for the first call to setImage with a 320x240 image, a base patch size of 30x30, and a scale increment of 1.2 is 15 ms, while subsequent calls with the same image size and parameters takes 1.5 ms.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>Nicholas Butko </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>2010 version 0.4 </dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="affde308529d9daafc0a50b8f3dc59c8e"></a><!-- doxytag: member="PatchList2::PatchList2" ref="affde308529d9daafc0a50b8f3dc59c8e" args="(cv::Size basePatchSize, cv::Size minSize=cv::Size(0, 0), cv::Size maxSize=cv::Size(0, 0), double scaleInc=1.2, double stepWidth=1, int dontCopyImage=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PatchList2::PatchList2 </td>
          <td>(</td>
          <td class="paramtype">cv::Size&#160;</td>
          <td class="paramname"> <em>basePatchSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Size&#160;</td>
          <td class="paramname"> <em>minSize</em> = <code>cv::Size(0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Size&#160;</td>
          <td class="paramname"> <em>maxSize</em> = <code>cv::Size(0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>scaleInc</em> = <code>1.2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>stepWidth</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>dontCopyImage</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">basePatchSize</td><td>The size of the patches that will be evaluated for containing the object. This should match the size of whatever filter will be applied to the patches. It may be set later, using <a class="el" href="class_patch_list2.html#ac311401e00c9b92b78f16decde313fcf" title="Set the base patch size, which is size of the object detector that you plan to apply. It is also the default search minSize, and other scale sizes are computed relative to it.">setBasePatchSize()</a>. At subsequent scales, the image is scaled up or down relative to this size. </td></tr>
    <tr><td class="paramname">minSize</td><td>Don't search for objects smaller than minSize. If minSize is (0,0) then baseObjectSize is used. </td></tr>
    <tr><td class="paramname">maxSize</td><td>Don't search for objects larger than maxSize. If maxSize is (0,0), then the upper bound on the object size is the smallest dimension of the image size. </td></tr>
    <tr><td class="paramname">scaleInc</td><td>Relative size of the object in the next scale, compared to the current one. scaleInc must be greater than 1. </td></tr>
    <tr><td class="paramname">stepWidth</td><td>Search interval between subsequent patches. A stepWidth of 1 means slide the object evaluation window over one pixel. 2 means only evaluate patches at every other pixel. 1.5 means search two and skip the third, etc. </td></tr>
    <tr><td class="paramname">dontCopyImage</td><td>Set to non-zero if you want efficiency, but not to look at patches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a7888f0b3980380fc8cffdb1f6de78916"></a><!-- doxytag: member="PatchList2::accumulateAndRemovePatchesBelowThreshold" ref="a7888f0b3980380fc8cffdb1f6de78916" args="(double threshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PatchList2::accumulateAndRemovePatchesBelowThreshold </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>threshold</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds the values in destInds to an accumulator. Any accumulator values that are below threshold are removed from the list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>Accumulator values below threshold will be removed from the <a class="el" href="class_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">PatchList</a>. -INFINITY will insure all patches are kept. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4143de78cdcd7289fc0e9011934dbc34"></a><!-- doxytag: member="PatchList2::fillImageWithPixelsOfSearchPatch" ref="a4143de78cdcd7289fc0e9011934dbc34" args="(cv::Mat &amp;dest, const SearchResult &amp;r) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PatchList2::fillImageWithPixelsOfSearchPatch </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_search_result.html">SearchResult</a> &amp;&#160;</td>
          <td class="paramname"> <em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the exact same pixels from the image patch that the filtering process sees. This is useful for pulling out hard background patches for training. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">im</td><td>Destination image for pixels.</td></tr>
    <tr><td class="paramname">r</td><td>A Patch <a class="el" href="struct_search_result.html" title="Auxilliary Tool: A data structure that keeps track of where objects were detected in the image...">SearchResult</a> from <a class="el" href="class_patch_list2.html#a1489591c934b623b9468a88f60888e9f" title="Get info about the patches that have not yet been removed from the PatchList since calling resetListT...">getRemainingPatches()</a> to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab0d7994f5800157b60ca6a6501219ac9"></a><!-- doxytag: member="PatchList2::getAccumImage" ref="ab0d7994f5800157b60ca6a6501219ac9" args="(cv::Mat &amp;image) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PatchList2::getAccumImage </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>image</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output of filtering accumulation process as an image which can be visualized. </p>
<p>This image contains that data that was accumulated by successive calls to <a class="el" href="class_patch_list2.html#a7888f0b3980380fc8cffdb1f6de78916" title="Adds the values in destInds to an accumulator. Any accumulator values that are below threshold are re...">accumulateAndRemovePatchesBelowThreshold()</a>. </p>

</div>
</div>
<a class="anchor" id="a7a502656f227cbe29052c2705de1574e"></a><!-- doxytag: member="PatchList2::getBasePatchSize" ref="a7a502656f227cbe29052c2705de1574e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Size PatchList2::getBasePatchSize </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the base patch size, which is size of the object detector that you plan to apply. It is also the default search minSize, and other scale sizes are computed relative to it. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The base patch size. </dd></dl>

</div>
</div>
<a class="anchor" id="a45898f4587da221047b6db2f23571e6f"></a><!-- doxytag: member="PatchList2::getCurrentListLength" ref="a45898f4587da221047b6db2f23571e6f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PatchList2::getCurrentListLength </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of remaining patches at this scale. Initially, this has all patches in the scale, but may be reduced by repeated calls to <a class="el" href="class_patch_list2.html#a7888f0b3980380fc8cffdb1f6de78916" title="Adds the values in destInds to an accumulator. Any accumulator values that are below threshold are re...">accumulateAndRemovePatchesBelowThreshold()</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of patches that have not been removed. </dd></dl>

</div>
</div>
<a class="anchor" id="ae25cd74434086f3e1282299b096e0ec5"></a><!-- doxytag: member="PatchList2::getFilterImage" ref="ae25cd74434086f3e1282299b096e0ec5" args="(cv::Mat &amp;image) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PatchList2::getFilterImage </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>image</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output of image filtering process as an image which can be visualized. </p>
<p>This image contains that data that is written in destInds by <a class="el" href="class_box_feature.html" title="Auxilliary Tool: A linear feature that uses the &quot;Integral  Image&quot; trick to efficiently eval...">BoxFeature</a> and <a class="el" href="class_feature_regressor.html" title="Auxilliary Tool: A data structure that learns a non-linear tuning curve for mapping feature outputs t...">FeatureRegressor</a> and <a class="el" href="class_gentle_boost_cascaded_classifier.html" title="  Machine Perception Primitive:   An implementation of a GentleBoost cascaded classifier for full ima...">GentleBoostCascadedClassifier</a>. </p>

</div>
</div>
<a class="anchor" id="a4d3f13d2b634c3603043364e87635c8d"></a><!-- doxytag: member="PatchList2::getFilterSizeAtScale" ref="a4d3f13d2b634c3603043364e87635c8d" args="(int scale=&#45;1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Size PatchList2::getFilterSizeAtScale </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>scale</em> = <code>-1</code>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the filter size that should be applied at this scale. For <a class="el" href="class_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">PatchList</a>, this is always <a class="el" href="class_patch_list2.html#a7a502656f227cbe29052c2705de1574e" title="Get the base patch size, which is size of the object detector that you plan to apply. It is also the default search minSize, and other scale sizes are computed relative to it.">getBasePatchSize()</a>. In <a class="el" href="class_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">PatchList</a>, this always returns <a class="el" href="class_patch_list2.html#a7a502656f227cbe29052c2705de1574e" title="Get the base patch size, which is size of the object detector that you plan to apply. It is also the default search minSize, and other scale sizes are computed relative to it.">getBasePatchSize()</a>. In <a class="el" href="class_fast_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">FastPatchList</a>, this always returns getPatchSizeAtScale(scale). </p>
<p>You must call <a class="el" href="class_patch_list2.html#a032c2487a9ec9c0ad752ded7ef548346" title="Set the image to filter or process for object detection.">setImage()</a> before. When querying scales for information, the maximum valid value is <a class="el" href="class_patch_list2.html#a116c3db117381ff18d499d62e278c13a" title="Get the total number of scales.">getNumScales()</a>-1, and the minimum is 0.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The scale to query. If -1, use the current. Otherwise, any valid scale can be queried. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae972e27f5ffed5e447470625a82c88d9"></a><!-- doxytag: member="PatchList2::getImageSizeAtScale" ref="ae972e27f5ffed5e447470625a82c88d9" args="(int scale=&#45;1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Size PatchList2::getImageSizeAtScale </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>scale</em> = <code>-1</code>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the size of the valid convolution image, for viewing filtering and accumulator results. </p>
<p>You must call <a class="el" href="class_patch_list2.html#a032c2487a9ec9c0ad752ded7ef548346" title="Set the image to filter or process for object detection.">setImage()</a> before because it is impossible to determine the filtered image size without knowing the image size. When querying scales for information, the maximum valid value is <a class="el" href="class_patch_list2.html#a116c3db117381ff18d499d62e278c13a" title="Get the total number of scales.">getNumScales()</a>-1, and the minimum is 0.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The scale to query. If -1, use the current. Otherwise, any valid scale can be queried. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ad023ddef8d01d4efc450261abad069"></a><!-- doxytag: member="PatchList2::getIntegralWidthStepAtScale" ref="a1ad023ddef8d01d4efc450261abad069" args="(int scale=&#45;1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PatchList2::getIntegralWidthStepAtScale </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>scale</em> = <code>-1</code>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the width step of the integral image, i.e. how many integral_type elements are there in srcInds[i][j] before a pixel that is directly below [j]. </p>
<p>You must call <a class="el" href="class_patch_list2.html#a032c2487a9ec9c0ad752ded7ef548346" title="Set the image to filter or process for object detection.">setImage()</a> before because it is impossible to determine the size of the integral image without knowing the image size. When querying scales for information, the maximum valid value is <a class="el" href="class_patch_list2.html#a116c3db117381ff18d499d62e278c13a" title="Get the total number of scales.">getNumScales()</a>-1, and the minimum is 0.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The scale to query. If -1, use the current. Otherwise, any valid scale can be queried. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa862bbd326e5c266f19160a6473e1720"></a><!-- doxytag: member="PatchList2::getNearbyPatches" ref="aa862bbd326e5c266f19160a6473e1720" args="(cv::Rect roi, int spatialRadius=0, int scaleRadius=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_image_patch2.html">ImagePatch2</a> &gt; PatchList2::getNearbyPatches </td>
          <td>(</td>
          <td class="paramtype">cv::Rect&#160;</td>
          <td class="paramname"> <em>roi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>spatialRadius</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>scaleRadius</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get patches near a region of interest. This is useful for augmenting the number of positive examples in a dataset by grabbing nearby patches, or for finding the image patch that is closest to a labelled location. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">roi</td><td>A region of interest in the image. </td></tr>
    <tr><td class="paramname">spatialRadius</td><td>Take patches that are slightly left/right/up/down from roi.Note that a radius of 1 gives 9 patches, and a radius of 2 gives 25. </td></tr>
    <tr><td class="paramname">scaleRadius</td><td>Take patches that are slightly larger or smaller than the roi. This size is radius is in terms of search scale, not pixels. Note that a radius of 1 gives 3 patches, and a radius of 2 gives 5. </td></tr>
  </table>
  </dd>
</dl>

<p><p>!!!! TODO : Check this out. -- Decide if we want this to be size of base patch or size of patch in image </p>
</p>

</div>
</div>
<a class="anchor" id="a116c3db117381ff18d499d62e278c13a"></a><!-- doxytag: member="PatchList2::getNumScales" ref="a116c3db117381ff18d499d62e278c13a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PatchList2::getNumScales </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the total number of scales. </p>
<p>You must call <a class="el" href="class_patch_list2.html#a032c2487a9ec9c0ad752ded7ef548346" title="Set the image to filter or process for object detection.">setImage()</a> before because it is impossible to determine the number of scales without knowing the image size. When querying scales for information, the maximum valid value is <a class="el" href="class_patch_list2.html#a116c3db117381ff18d499d62e278c13a" title="Get the total number of scales.">getNumScales()</a>-1, and the minimum is 0.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Total number of patches available to this <a class="el" href="class_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">PatchList</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a4fdf620fc4d60224e2cc676a1d908b63"></a><!-- doxytag: member="PatchList2::getPatchSizeAtScale" ref="a4fdf620fc4d60224e2cc676a1d908b63" args="(int scale=&#45;1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Size PatchList2::getPatchSizeAtScale </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>scale</em> = <code>-1</code>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the effective object size if searching at a given (or the current) scale. </p>
<p>You must call <a class="el" href="class_patch_list2.html#a032c2487a9ec9c0ad752ded7ef548346" title="Set the image to filter or process for object detection.">setImage()</a> before because it is impossible to determine the number of patch sizes without knowing the image size. When querying scales for information, the maximum valid value is <a class="el" href="class_patch_list2.html#a116c3db117381ff18d499d62e278c13a" title="Get the total number of scales.">getNumScales()</a>-1, and the minimum is 0.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The scale to query. If -1, use the current. Otherwise, any valid scale can be queried. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1489591c934b623b9468a88f60888e9f"></a><!-- doxytag: member="PatchList2::getRemainingPatches" ref="a1489591c934b623b9468a88f60888e9f" args="(std::vector&lt; SearchResult &gt; &amp;searchResults) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PatchList2::getRemainingPatches </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_search_result.html">SearchResult</a> &gt; &amp;&#160;</td>
          <td class="paramname"> <em>searchResults</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get info about the patches that have not yet been removed from the <a class="el" href="class_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">PatchList</a> since calling <a class="el" href="class_patch_list2.html#a40238c55e4ca38a85cf8f20b81edd73c" title="Prepare the data structure to search for objects at a certain scale.">resetListToScale()</a>. Each <a class="el" href="struct_search_result.html" title="Auxilliary Tool: A data structure that keeps track of where objects were detected in the image...">SearchResult</a> contains info about the location of the patch in the original image, and its current accumulator value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">searchResults</td><td>The vector that will be filled with the remaining patches. The contents of the vector passed in are entirely overwritten. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6436afeb46c61dabc1ea52dd50533a18"></a><!-- doxytag: member="PatchList2::getTotalPatches" ref="a6436afeb46c61dabc1ea52dd50533a18" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PatchList2::getTotalPatches </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the total number of patches available to this <a class="el" href="class_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">PatchList</a> at all scales. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Total number of patches available to this <a class="el" href="class_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">PatchList</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b91aa6a987b6820221f1a8002804b7d"></a><!-- doxytag: member="PatchList2::keepOnlyLocalMaxima" ref="a0b91aa6a987b6820221f1a8002804b7d" args="(int radius)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PatchList2::keepOnlyLocalMaxima </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>radius</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove image patch candidates that have a nearby patch (within radius horizontal or vertical pixels) with a higher value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">radius</td><td>Radius (in pixels) to do non-maximal suppression. Pixels are scale-adjusted, so the suppression region grows with the size of the object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a40238c55e4ca38a85cf8f20b81edd73c"></a><!-- doxytag: member="PatchList2::resetListToScale" ref="a40238c55e4ca38a85cf8f20b81edd73c" args="(int scale)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PatchList2::resetListToScale </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>scale</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepare the data structure to search for objects at a certain scale. </p>
<p>You must call <a class="el" href="class_patch_list2.html#a032c2487a9ec9c0ad752ded7ef548346" title="Set the image to filter or process for object detection.">setImage()</a> before because it is impossible to determine various scale info without knowing the image size. When querying scales for information, the maximum valid value is <a class="el" href="class_patch_list2.html#a116c3db117381ff18d499d62e278c13a" title="Get the total number of scales.">getNumScales()</a>-1, and the minimum is 0.</p>
<p>Scales number from 0 to <a class="el" href="class_patch_list2.html#a116c3db117381ff18d499d62e278c13a" title="Get the total number of scales.">getNumScales()</a>-1. 0 searches for smallest objects, <a class="el" href="class_patch_list2.html#a116c3db117381ff18d499d62e278c13a" title="Get the total number of scales.">getNumScales()</a>-1 searches for the largest. </p>

</div>
</div>
<a class="anchor" id="ac311401e00c9b92b78f16decde313fcf"></a><!-- doxytag: member="PatchList2::setBasePatchSize" ref="ac311401e00c9b92b78f16decde313fcf" args="(cv::Size baseSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PatchList2::setBasePatchSize </td>
          <td>(</td>
          <td class="paramtype">cv::Size&#160;</td>
          <td class="paramname"> <em>baseSize</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the base patch size, which is size of the object detector that you plan to apply. It is also the default search minSize, and other scale sizes are computed relative to it. </p>
<p>This can be changed somewhat freely, but <a class="el" href="class_patch_list2.html#a032c2487a9ec9c0ad752ded7ef548346" title="Set the image to filter or process for object detection.">setImage()</a> must be called afterward.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">baseSize</td><td>The base patch size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ef4a7f176e16bf65a33ad2643422ef4"></a><!-- doxytag: member="PatchList2::setDontCopyImageData" ref="a1ef4a7f176e16bf65a33ad2643422ef4" args="(int flag=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PatchList2::setDontCopyImageData </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>flag</em> = <code>0</code>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Improve efficiency by only copying integral data (not image data). This makes fillImageWithPixelsOfSearchPatch fail. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>Set to non-zero if you want efficiency, but not to look at patches. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a59f7444d0242fa888c67a837883a21fd"></a><!-- doxytag: member="PatchList2::setDontScaleDownPatches" ref="a59f7444d0242fa888c67a837883a21fd" args="(int flag=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PatchList2::setDontScaleDownPatches </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>flag</em> = <code>0</code>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Improve detail of patches when getting pixels of patch -- at the cost of extra memory. Only affects <a class="el" href="class_fast_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">FastPatchList</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>Set to non-zero if you want big patches for training with <a class="el" href="class_fast_patch_list.html" title="Auxilliary Tool: A class that does the necessary book keeping for filtering an image quickly at many ...">FastPatchList</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a032c2487a9ec9c0ad752ded7ef548346"></a><!-- doxytag: member="PatchList2::setImage" ref="a032c2487a9ec9c0ad752ded7ef548346" args="(const cv::Mat &amp;newImage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PatchList2::setImage </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>newImage</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the image to filter or process for object detection. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">newImage</td><td>The image to process must be a single channel image of CV_8U. It can be of any size, but passing images of the same size repeatedly will boost performance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="acf1985dcd452f910a28c641ebe00ff63"></a><!-- doxytag: member="PatchList2::destInds" ref="acf1985dcd452f910a28c641ebe00ff63" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double*&gt; <a class="el" href="class_patch_list2.html#acf1985dcd452f910a28c641ebe00ff63">PatchList2::destInds</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A list of pointers to corresponding to the filtering outputs of the remaining candidate patches in srcInds. </p>
<p>This is a place for <a class="el" href="class_box_feature.html" title="Auxilliary Tool: A linear feature that uses the &quot;Integral  Image&quot; trick to efficiently eval...">BoxFeature</a>, <a class="el" href="class_feature_regressor.html" title="Auxilliary Tool: A data structure that learns a non-linear tuning curve for mapping feature outputs t...">FeatureRegressor</a>, <a class="el" href="class_gentle_boost_cascaded_classifier.html" title="  Machine Perception Primitive:   An implementation of a GentleBoost cascaded classifier for full ima...">GentleBoostCascadedClassifier</a> etc. to store their outputs. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/nick/projects/NickThesis/Code/OpenCV/src/PatchList2.h</li>
<li>/Users/nick/projects/NickThesis/Code/OpenCV/src/PatchList2.cpp</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Dec 9 2010 16:05:49 for Nick's Machine Perception Toolbox by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
