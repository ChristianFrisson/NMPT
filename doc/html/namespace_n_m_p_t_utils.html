<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Nick&#39;s Machine Perception Toolbox: NMPTUtils Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>NMPTUtils Namespace Reference<br/>
<small>
[<a class="el" href="group___aux_group.html">Auxilliary Tools</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p><code>Auxilliary Tool:</code> A set of functions that are commonly used by many NMPT classes and executables.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a008755390bc893fd51c69fb1a7b8ac3e"></a><!-- doxytag: member="NMPTUtils::printMat" ref="a008755390bc893fd51c69fb1a7b8ac3e" args="(const cv::Mat &amp;mat)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_n_m_p_t_utils.html#a008755390bc893fd51c69fb1a7b8ac3e">printMat</a> (const cv::Mat &amp;mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Display a matrix to stdout in a multi line format easy to read. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec81e6bb038e377d42ea7834a7e76deb"></a><!-- doxytag: member="NMPTUtils::printMat" ref="aec81e6bb038e377d42ea7834a7e76deb" args="(const CvMat &amp;mat)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_n_m_p_t_utils.html#aec81e6bb038e377d42ea7834a7e76deb">printMat</a> (const CvMat &amp;mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Display a matrix to stdout in a multi line format easy to read. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6856021afa3f6292ca9df56a63ffa4a5"></a><!-- doxytag: member="NMPTUtils::randomNormal" ref="a6856021afa3f6292ca9df56a63ffa4a5" args="()" -->
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_n_m_p_t_utils.html#a6856021afa3f6292ca9df56a63ffa4a5">randomNormal</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a single normally distributed random number. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae184bd06e354fb4bbf641d4202e3e98b"></a><!-- doxytag: member="NMPTUtils::randomFloat" ref="ae184bd06e354fb4bbf641d4202e3e98b" args="()" -->
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_n_m_p_t_utils.html#ae184bd06e354fb4bbf641d4202e3e98b">randomFloat</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a single random number distributed uniformly from 0-1. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a2cad58698acb626d3910e76557553d"></a><!-- doxytag: member="NMPTUtils::commaSeparatedFlattenedMat" ref="a0a2cad58698acb626d3910e76557553d" args="(const cv::Mat &amp;mat)" -->
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_n_m_p_t_utils.html#a0a2cad58698acb626d3910e76557553d">commaSeparatedFlattenedMat</a> (const cv::Mat &amp;mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a matrix in a single line, comma separated format suitable for output to a CSV file. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_n_m_p_t_utils.html#a5eaa5d80cd3aeb53810fb58d861d2c15">getVideoCaptureFromCommandLineArgs</a> (cv::VideoCapture &amp;capture, const int argc, const char **argv)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the source for an NMPT program to be specified from the command line.  <a href="#a5eaa5d80cd3aeb53810fb58d861d2c15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa672ee5c40a3520b8148eac72b31a22"></a><!-- doxytag: member="NMPTUtils::rectAreaOverlapRatio" ref="afa672ee5c40a3520b8148eac72b31a22" args="(cv::Rect r1, cv::Rect r2)" -->
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_n_m_p_t_utils.html#afa672ee5c40a3520b8148eac72b31a22">rectAreaOverlapRatio</a> (cv::Rect r1, cv::Rect r2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the ratio of the area of the intersection of two rectangles to the area of the union. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5f8b3988027ac74fc60bd489e8858b7"></a><!-- doxytag: member="NMPTUtils::rectAreaIntersect" ref="aa5f8b3988027ac74fc60bd489e8858b7" args="(cv::Rect r1, cv::Rect r2)" -->
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_n_m_p_t_utils.html#aa5f8b3988027ac74fc60bd489e8858b7">rectAreaIntersect</a> (cv::Rect r1, cv::Rect r2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the area of the intersection of two rectangles. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab97a7b222b5f59fab92c33b97122db79"></a><!-- doxytag: member="NMPTUtils::notfinite" ref="ab97a7b222b5f59fab92c33b97122db79" args="(double a)" -->
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_n_m_p_t_utils.html#ab97a7b222b5f59fab92c33b97122db79">notfinite</a> (double a)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a is NaN or infinty. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac935d21dcb9001d47f6efabe5ea1c85b"></a><!-- doxytag: member="NMPTUtils::distNorm" ref="ac935d21dcb9001d47f6efabe5ea1c85b" args="(cv::Mat &amp;normDist, const cv::Mat &amp;unnormDist)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_n_m_p_t_utils.html#ac935d21dcb9001d47f6efabe5ea1c85b">distNorm</a> (cv::Mat &amp;normDist, const cv::Mat &amp;unnormDist)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides unnormDist by its L1-norm, effectively turning it into a probability distribution's histogram. The values of unnormDist should be all positive. If any values are NaN or inf, the probability mass is split uniformly between those values and all other values become 0. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a855fb458d57708334123f1a2c88e9353"></a><!-- doxytag: member="NMPTUtils::sample" ref="a855fb458d57708334123f1a2c88e9353" args="(cv::Mat &amp;samples, const cv::Mat &amp;histogram, cv::Size sampleSize=cv::Size(1, 1))" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_n_m_p_t_utils.html#a855fb458d57708334123f1a2c88e9353">sample</a> (cv::Mat &amp;samples, const cv::Mat &amp;histogram, cv::Size sampleSize=cv::Size(1, 1))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a matrix of samples from a probability histogram. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99b7458bf4fcac68118765beeac3f834"></a><!-- doxytag: member="NMPTUtils::sample" ref="a99b7458bf4fcac68118765beeac3f834" args="(const cv::Mat &amp;histogram)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_n_m_p_t_utils.html#a99b7458bf4fcac68118765beeac3f834">sample</a> (const cv::Mat &amp;histogram)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a single sample from a probability histogram. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a2f1b005a9872955ae92b61639a895af8"></a><!-- doxytag: member="NMPTUtils::map" ref="a2f1b005a9872955ae92b61639a895af8" args="(cv::Mat &amp;mat, mattype(*function)(mattype))" -->
template&lt;class mattype &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_n_m_p_t_utils.html#a2f1b005a9872955ae92b61639a895af8">map</a> (cv::Mat &amp;mat, mattype(*function)(mattype))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function (in place) to every element of a matrix. The function must take an argument of the matrix's data type, and return a value of the matrix's data type. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a34f365c74d3955064ede2612b8f296e9"></a><!-- doxytag: member="NMPTUtils::contains" ref="a34f365c74d3955064ede2612b8f296e9" args="(const cv::Mat &amp;mat, mattype val)" -->
template&lt;class mattype &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_n_m_p_t_utils.html#a34f365c74d3955064ede2612b8f296e9">contains</a> (const cv::Mat &amp;mat, mattype val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if a matrix contains a certain value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa22c123eae028abb08b1b9eb21efd936"></a><!-- doxytag: member="NMPTUtils::nchoosek" ref="aa22c123eae028abb08b1b9eb21efd936" args="(int n, int k)" -->
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_n_m_p_t_utils.html#aa22c123eae028abb08b1b9eb21efd936">nchoosek</a> (int n, int k)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Quickly computer the n choose k function. The result is accurate through at least the range of 32-bit integers. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41e755fae1e6d52e6b786ae65462deba"></a><!-- doxytag: member="NMPTUtils::any" ref="a41e755fae1e6d52e6b786ae65462deba" args="(CvMat *mat)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_n_m_p_t_utils.html#a41e755fae1e6d52e6b786ae65462deba">any</a> (CvMat *mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if any member of mat is non-zero. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ae7b40c79a2b744c2fa13bba97bde37e7"></a><!-- doxytag: member="NMPTUtils::any" ref="ae7b40c79a2b744c2fa13bba97bde37e7" args="(const cv::Mat &amp;mat)" -->
template&lt;class mattype &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_n_m_p_t_utils.html#ae7b40c79a2b744c2fa13bba97bde37e7">any</a> (const cv::Mat &amp;mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if any member of mat is non-zero. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa52b36a9f653006905af882a677a8978"></a><!-- doxytag: member="NMPTUtils::fix" ref="aa52b36a9f653006905af882a677a8978" args="(CvMat *mat)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_n_m_p_t_utils.html#aa52b36a9f653006905af882a677a8978">fix</a> (CvMat *mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Round the elements of mat towards zero. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97a3b8a8f09099c29196cef01128e7a5"></a><!-- doxytag: member="NMPTUtils::writeMatBinary" ref="a97a3b8a8f09099c29196cef01128e7a5" args="(cv::FileStorage &amp;storage, const std::string &amp;name, const cv::Mat &amp;mat)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_n_m_p_t_utils.html#a97a3b8a8f09099c29196cef01128e7a5">writeMatBinary</a> (cv::FileStorage &amp;storage, const std::string &amp;name, const cv::Mat &amp;mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the value of a matrix to a FileStorage in a Base64 format that is much more compact than OpenCV's default format. The data is keyed by the supplied name. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b908ca6f7843f5aad43f88acd985e13"></a><!-- doxytag: member="NMPTUtils::readMatBinary" ref="a0b908ca6f7843f5aad43f88acd985e13" args="(const cv::FileNode &amp;storage, cv::Mat &amp;mat)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_n_m_p_t_utils.html#a0b908ca6f7843f5aad43f88acd985e13">readMatBinary</a> (const cv::FileNode &amp;storage, cv::Mat &amp;mat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the value of a matrix to a FileStorage in a Base64 format that is much more compact than OpenCV's default format. The data is keyed by the supplied name. If you attempt to read a matrix that was not saved with "writeMatBinary," this will probably crash your program. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_n_m_p_t_utils.html#a053fd7582b903797d0b38e2b25177755">binaryToAscii</a> (std::string &amp;dest, const uchar *data, size_t bytes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the value of a matrix to a FileStorage in a Base64 format that is much more compact than OpenCV's default format. The data is keyed by the supplied name. The data is uncompressed with zlib after writing. If you attempt to read a matrix that was not saved with "writeMatBinaryCompressed," this will probably crash your program.  <a href="#a053fd7582b903797d0b38e2b25177755"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab56693fb2b10fafa1d6b5b2faae2d96e"></a><!-- doxytag: member="NMPTUtils::asciiToBinary" ref="ab56693fb2b10fafa1d6b5b2faae2d96e" args="(const std::string &amp;data, uchar *dest, size_t bytes)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_n_m_p_t_utils.html#ab56693fb2b10fafa1d6b5b2faae2d96e">asciiToBinary</a> (const std::string &amp;data, uchar *dest, size_t bytes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a Base64 string to binary data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30b1a998291a30dc1e5d779bd0d84f49"></a><!-- doxytag: member="NMPTUtils::binaryToHex" ref="a30b1a998291a30dc1e5d779bd0d84f49" args="(std::string &amp;dest, const uchar *data, size_t bytes)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_n_m_p_t_utils.html#a30b1a998291a30dc1e5d779bd0d84f49">binaryToHex</a> (std::string &amp;dest, const uchar *data, size_t bytes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts binary data to a non-standard hex format that can be written to a text file, e.g. the YAML format written by OpenCV. This format requires 1.5 the storage space of Base64. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a987ac9b301718fceab0452ede8de877a"></a><!-- doxytag: member="NMPTUtils::hexToBinary" ref="a987ac9b301718fceab0452ede8de877a" args="(const std::string &amp;data, uchar *dest, size_t bytes)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_n_m_p_t_utils.html#a987ac9b301718fceab0452ede8de877a">hexToBinary</a> (const std::string &amp;data, uchar *dest, size_t bytes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a non-standard hex format to binary data. This format requires 1.5 the storage space of Base64. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8cb05bf87c9ceb4f1ddc4123a482a934"></a><!-- doxytag: member="NMPTUtils::splitString" ref="a8cb05bf87c9ceb4f1ddc4123a482a934" args="(std::vector&lt; std::string &gt; &amp;dest, const std::string &amp;data, size_t maxlen=512)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_n_m_p_t_utils.html#a8cb05bf87c9ceb4f1ddc4123a482a934">splitString</a> (std::vector&lt; std::string &gt; &amp;dest, const std::string &amp;data, size_t maxlen=512)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a string into a collection of string vectors, each with maximum length maxlen. This is useful because OpenCV imposes a maximum string length when writing to a file, somewhere between 2048 and 4096. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5783855577804d5b87181cbdc21bed7f"></a><!-- doxytag: member="NMPTUtils::joinString" ref="a5783855577804d5b87181cbdc21bed7f" args="(const std::vector&lt; std::string &gt; &amp;data, std::string &amp;dest)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_n_m_p_t_utils.html#a5783855577804d5b87181cbdc21bed7f">joinString</a> (const std::vector&lt; std::string &gt; &amp;data, std::string &amp;dest)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rejoins a vector of strings into a single string. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_n_m_p_t_utils.html#ac0bb8480411e4a5a90304072268f5b56">rectangleRotated</a> (cv::Mat &amp;image, cv::Point center, cv::Size size, double angle, const cv::Scalar &amp;color, int thickness=1, int lineType=8, int shift=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses zlib to compress data. The output dest is allocated in this function and dest_size is set to the number of bytes of the compressed data. Returns a zlib error code if compression fails.  <a href="#ac0bb8480411e4a5a90304072268f5b56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaad3405afa7c6ac1f72e22443402448e"></a><!-- doxytag: member="NMPTUtils::unIntegrate" ref="aaad3405afa7c6ac1f72e22443402448e" args="(const cv::Mat &amp;src, cv::Mat &amp;dest, int type=CV_8U)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_n_m_p_t_utils.html#aaad3405afa7c6ac1f72e22443402448e">unIntegrate</a> (const cv::Mat &amp;src, cv::Mat &amp;dest, int type=CV_8U)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate derivative image. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef9901d35cd820bfdcc0125f7eafb187"></a><!-- doxytag: member="NMPTUtils::unSqIntegrate" ref="aef9901d35cd820bfdcc0125f7eafb187" args="(const cv::Mat &amp;src, cv::Mat &amp;dest, int type=CV_8U)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_n_m_p_t_utils.html#aef9901d35cd820bfdcc0125f7eafb187">unSqIntegrate</a> (const cv::Mat &amp;src, cv::Mat &amp;dest, int type=CV_8U)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate sqrt of derivative image. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_n_m_p_t_utils.html#ac96d8fa18e73473f515743eae8d30ae0">RBF</a> (const cv::Mat &amp;input, const cv::Mat &amp;labels, const cv::Mat &amp;weights, const cv::Mat &amp;xqueries, double tau=.05, double eps=.001)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute RBF values at supplied query points, given input data and labels.  <a href="#ac96d8fa18e73473f515743eae8d30ae0"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><code>Auxilliary Tool:</code> A set of functions that are commonly used by many NMPT classes and executables. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Nicholas Butko </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>2010 </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>0.4 </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a053fd7582b903797d0b38e2b25177755"></a><!-- doxytag: member="NMPTUtils::binaryToAscii" ref="a053fd7582b903797d0b38e2b25177755" args="(std::string &amp;dest, const uchar *data, size_t bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NMPTUtils::binaryToAscii </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"> <em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read the value of a matrix to a FileStorage in a Base64 format that is much more compact than OpenCV's default format. The data is keyed by the supplied name. The data is uncompressed with zlib after writing. If you attempt to read a matrix that was not saved with "writeMatBinaryCompressed," this will probably crash your program. </p>
<p>Converts binary data to a Base64 string that can be written to a text file, e.g. the YAML format written by OpenCV. </p>

</div>
</div>
<a class="anchor" id="a5eaa5d80cd3aeb53810fb58d861d2c15"></a><!-- doxytag: member="NMPTUtils::getVideoCaptureFromCommandLineArgs" ref="a5eaa5d80cd3aeb53810fb58d861d2c15" args="(cv::VideoCapture &amp;capture, const int argc, const char **argv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int NMPTUtils::getVideoCaptureFromCommandLineArgs </td>
          <td>(</td>
          <td class="paramtype">cv::VideoCapture &amp;&#160;</td>
          <td class="paramname"> <em>capture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"> <em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"> <em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allows the source for an NMPT program to be specified from the command line. </p>
<ul>
<li>If the program is invoked with no arguments, the default camera is used. </li>
<li>If the program is invoked with any options (e.g. --help), a usage message is printed. </li>
<li>If the program is invoked with an integer argument between 0 and 9, the camera with the corresponding number is used. </li>
<li>If the program is invoked with a single string argument, it is interpererted as a path to a video file, which will be used for the source.</li>
</ul>
<p>Returns 0 if there was an error, 1 if a video file was the source, or 2 if a camera was the source, </p>

</div>
</div>
<a class="anchor" id="ac96d8fa18e73473f515743eae8d30ae0"></a><!-- doxytag: member="NMPTUtils::RBF" ref="ac96d8fa18e73473f515743eae8d30ae0" args="(const cv::Mat &amp;input, const cv::Mat &amp;labels, const cv::Mat &amp;weights, const cv::Mat &amp;xqueries, double tau=.05, double eps=.001)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat NMPTUtils::RBF </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>xqueries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>tau</em> = <code>.05</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>eps</em> = <code>.001</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute RBF values at supplied query points, given input data and labels. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>NxM, N data points, M Dims </td></tr>
    <tr><td class="paramname">labels</td><td>NxO, N data points, O outputs </td></tr>
    <tr><td class="paramname">weights</td><td>Nx1, 1 weight per data point </td></tr>
    <tr><td class="paramname">xqueries</td><td>QxM, Q query points, M Dims </td></tr>
    <tr><td class="paramname">tau,:</td><td>variance of gaussian weighting window </td></tr>
    <tr><td class="paramname">eps,:</td><td>minimal attention paid to all points</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>QxO RBF values, Q query points, O output dimensions. </dd></dl>

</div>
</div>
<a class="anchor" id="ac0bb8480411e4a5a90304072268f5b56"></a><!-- doxytag: member="NMPTUtils::rectangleRotated" ref="ac0bb8480411e4a5a90304072268f5b56" args="(cv::Mat &amp;image, cv::Point center, cv::Size size, double angle, const cv::Scalar &amp;color, int thickness=1, int lineType=8, int shift=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NMPTUtils::rectangleRotated </td>
          <td>(</td>
          <td class="paramtype">cv::Mat &amp;&#160;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Point&#160;</td>
          <td class="paramname"> <em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Size&#160;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Scalar &amp;&#160;</td>
          <td class="paramname"> <em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>thickness</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>lineType</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>shift</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Uses zlib to compress data. The output dest is allocated in this function and dest_size is set to the number of bytes of the compressed data. Returns a zlib error code if compression fails. </p>
<p>Uncompress data that was previously compressed. The output dest is allocated in this function, to the amount specified by dest_size. This should be the size of the original uncompressed data, which presumably you know, because you compressed it. Returns a zlib error code if decompression fails. Draw a rotated rectangle on an image. The point is to be like opencv's cv::rectangle function, but to allow rotation. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Dec 9 2010 16:05:49 for Nick's Machine Perception Toolbox by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
